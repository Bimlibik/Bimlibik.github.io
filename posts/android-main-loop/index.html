<!DOCTYPE html><html lang="ru-RU" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Main Loop (Главный цикл) в Android" /><meta name="author" content="Bimlibik" /><meta property="og:locale" content="ru_RU" /><meta name="description" content="Не так давно наткнулась на серию статей про главный цикл в android, которые показались мне очень интересными. Поэтому сохраняю на память." /><meta property="og:description" content="Не так давно наткнулась на серию статей про главный цикл в android, которые показались мне очень интересными. Поэтому сохраняю на память." /><link rel="canonical" href="http://bimlibik.github.io/posts/android-main-loop/" /><meta property="og:url" content="http://bimlibik.github.io/posts/android-main-loop/" /><meta property="og:site_name" content="Bimlibik" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-05T23:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Main Loop (Главный цикл) в Android" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Bimlibik" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Не так давно наткнулась на серию статей про главный цикл в android, которые показались мне очень интересными. Поэтому сохраняю на память.","headline":"Main Loop (Главный цикл) в Android","dateModified":"2021-12-05T23:00:00+08:00","datePublished":"2021-12-05T23:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://bimlibik.github.io/posts/android-main-loop/"},"url":"http://bimlibik.github.io/posts/android-main-loop/","author":{"@type":"Person","name":"Bimlibik"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>Main Loop (Главный цикл) в Android | Bimlibik</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-159618579-2"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-159618579-2'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Bimlibik</a></div><div class="site-subtitle font-italic">База статей по Android и Kotlin.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>ГЛАВНАЯ</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>КАТЕГОРИИ</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>ТЕГИ</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>АРХИВ</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>О САЙТЕ</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Bimlibik" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Статьи </a> </span> <span>Main Loop (Главный цикл) в Android</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Поиск..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Main Loop (Главный цикл) в Android</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="05.12.2021, 23:00" prefix="Опубликовано " > 05 December 2021 <i class="unloaded">2021-12-05T23:00:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="Всего слов - 11600"> Время чтения 64 мин. </span></div></div><div class="post-content"><p>Не так давно наткнулась на серию статей про главный цикл в android, которые показались мне очень интересными. Поэтому сохраняю на память.</p><hr /><h2 id="пишем-свой-цикл">Пишем свой цикл</h2><p>Основой любого приложения является его главный поток. На нём происходят все самые важные вещи: создаются другие потоки, меняется UI. Важнейшей его частью является цикл. Так как поток главный, то и его цикл тоже главный - в простонародье <strong>Main Loop</strong>.</p><p>Тонкости работы главного цикла уже описаны в Android SDK, а разработчики лишь взаимодействуют с ним. Поэтому, хотелось бы разобраться подробней, как работает главный цикл, для чего нужен, какие проблемы решает и какие у него есть особенности.</p><p>Вообще, лучший способ понять, как что-то работает - сделать это самому. Поэтому, прежде чем лезть в дебри Android SDK давайте попробуем написать свой цикл, правда без блэкджека и прочего. Наоборот, это будет минимально работоспособный цикл, но зато хорошо демонстрирующий основную логику, без лишней мишуры.</p><h3 id="как-вообще-работают-программы">Как вообще работают программы</h3><p>Но для начала, давайте разберёмся как вообще работают простые программы в Java.</p><p>С точки зрения системы - всё что есть у программы это просто метод <code class="language-plaintext highlighter-rouge">main</code> который она вызовет при старте и завершит процесс после его выполнения.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/simple-program.png" alt="simple program" /></p><p>В коде это выглядит примерно так - у нас есть класс и внутри него метод <code class="language-plaintext highlighter-rouge">main</code>, который и вызовется системой. В данном случае мы просто выведем <strong>Hello World</strong> в консоль.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">myjavacode</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Вместо вывода в лог мы можем открыть экран, выполнить сложную операцию или отправить запрос в сеть. Суть не изменится: после выполнения метода <code class="language-plaintext highlighter-rouge">main</code> - программа закроется. Программа или, если говорить в контексте Android - приложение, живёт пока что-то делает, затем просто завершается.</p><p>Почему так сделано? Изначально программы делались для командной строки, где основным методом взаимодействия является либо передача входных данных в виде аргументов, либо ввод данных пользователем в командную строку в процессе исполнения программы. После того как программа выполняла свою основную задачу ей просто не было смысла работать дальше, и такая программа завершала работу.</p><p>В программах использующих UI и в частности в Android приложениях - все не так. Приложение не закрывается как только сделает все что ему было предписано на старте. Оно терпеливо ждёт действий пользователя, кликов и прочего, и затем реагирует на них. Поэтому, приложения с UI должны жить и работать пока пользователь сам его не закроет (ну или пока приложение не упадет, или система сама его не закроет по причине нехватки памяти). Но вот проблема: как только последняя строчка метода <code class="language-plaintext highlighter-rouge">main</code> выполнится - приложение закроется само, так как посчитает, что оно сделало всё что нужно.</p><h3 id="как-не-дать-приложению-закрыться">Как не дать приложению закрыться?</h3><p>Для начала давайте разберёмся с тем, как же нам не дать приложению завершаться самостоятельно. Самый простой и самый действенный метод - (почти) бесконечный цикл. Проще всего его создать через обычный <code class="language-plaintext highlighter-rouge">while</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">isAlive</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">isAlive</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">doAction</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doAction</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>По сути, мы просто добавили (почти) бесконечный цикл в котором вызывается метод <code class="language-plaintext highlighter-rouge">doAction</code> и теперь наше приложение уже не будет закрываться само, ведь цикл то бесконечный, а значит и приложению всегда есть что делать. Оно будет бесконечно выполнять метод <code class="language-plaintext highlighter-rouge">doAction</code> пока мы не попросим его наконец остановиться, переключив переменную <code class="language-plaintext highlighter-rouge">isAlive</code> в состояние <code class="language-plaintext highlighter-rouge">false</code>. Проблема только в том, что наше приложение пока ничего не делает. Метод <code class="language-plaintext highlighter-rouge">doAction</code> то пустой.</p><h3 id="заставляем-приложение-что-то-делать">Заставляем приложение что-то делать</h3><p>Теперь добавим возможность приложению выполнять какие-либо действия. Просто написать код всей программы в методе <code class="language-plaintext highlighter-rouge">doAction</code> не очень хороший вариант. В приложении могут быть сотни кнопок и текстовых полей на каждое из которых нужно написать свое действие. Если писать всё в одном методе то он довольно быстро превратится в нечитаемое чудовище размером в несколько десятков тысяч строк.</p><p>Поэтому воспользуемся <a href="https://ru.wikipedia.org/wiki/Callback_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="ru.wikipedia.org">функцией обратного вызова</a> - в простонародье <code class="language-plaintext highlighter-rouge">callback</code>. Благо в Java уже есть интерфейс <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html" title="docs.oracle.com">Runnable</a> который хорошо для этого подходит. У него есть всего один метод <code class="language-plaintext highlighter-rouge">run</code>, который можно переопределить и написать туда своё действие.</p><p>Для того, чтобы понимать какое действие надо выполнить следующим поместим их в очередь. Пока для нее сгодится обычный <code class="language-plaintext highlighter-rouge">ArrayList</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">availableActions</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">isAlive</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">isAlive</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">doAction</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doAction</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">availableActions</span><span class="o">.</span><span class="na">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Runnable</span> <span class="n">currentAction</span> <span class="o">=</span> <span class="n">availableActions</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="n">currentAction</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
            <span class="n">availableActions</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">currentAction</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Теперь в нашем цикле мы проверяем есть ли доступные действия. Если есть, то выполняем действие и удаляем его из списка доступных действий. Осталось только добавить какое-то действие в нашу очередь.</p><p>Для этого давайте представим, что у класса <code class="language-plaintext highlighter-rouge">System</code> есть возможность добавить слушатель на нажатия экрана вызвав метод - <code class="language-plaintext highlighter-rouge">registerClickListener</code>. В обратном вызове слушателя добавим какое-нибудь действие в очередь. Например, выведем в лог <strong>Click on screen</strong>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">availableActions</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">isAlive</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">registerClickListener</span><span class="o">((</span><span class="n">clickEvent</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">availableActions</span><span class="o">.</span><span class="na">add</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="s">"Click on screen"</span><span class="o">));</span>
        <span class="o">});</span>
        <span class="k">while</span><span class="o">(</span><span class="n">isAlive</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">doAction</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doAction</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">availableActions</span><span class="o">.</span><span class="na">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Runnable</span> <span class="n">currentAction</span> <span class="o">=</span> <span class="n">availableActions</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="n">currentAction</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
            <span class="n">availableActions</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">currentAction</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Отлично! Теперь у нас есть приложение которое способно выводить сообщение в лог при нажатии на экран. Без цикла у нас бы ничего не вышло, ведь сразу после регистрации слушателя нажатий на экран, приложение закрылось бы и соответственно ни один клик не был бы обработан.</p><p>Новые действия могут добавляться в нашу очередь как от вызовов системы, так и внутри самих действий. То есть какое-то действие добавляет новое действие, а то добавляет ещё 5 новых и так до бесконечности.</p><p>Вроде всё хорошо, но есть один нюанс… Наше приложение теперь делает «что-то» постоянно. Даже когда у него нет доступных действий оно бесконечно проверяет не появились ли они. Тем самым оно постоянно загружает ядро процессора по максимуму, что явно не лучшим образом скажется на фоновых процессах, энергопотреблении и температуре самого процессора.</p><h3 id="заставляем-приложение-ничего-не-делать">Заставляем приложение ничего не делать</h3><p><em>Для того, чтобы дальнейшие действия выглядели менее абсурдными для тех кто разбирается - представим, что обратный вызов на нажатия на экран вызывается с какого-то отдельного потока системы.</em></p><p>Нам нужно указать, что если у нас пока нет доступных действий, то пора ничего не делать. Для этого воспользуемся стандартным методом <code class="language-plaintext highlighter-rouge">wait()</code> который заставляет текущий поток ждать и соответственно - бездействовать.</p><p>Так же, когда случится обратный вызов от нажатия на экран нам надо сказать нашему потоку, что пора поработать и проверить наличие доступных для выполнения действий. Для этого воспользуемся стандартным методом <code class="language-plaintext highlighter-rouge">notify()</code> который «разбудит наш поток».</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">availableActions</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">isAlive</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">registerClickLister</span><span class="o">((</span><span class="n">clickEvent</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">availableActions</span><span class="o">.</span><span class="na">add</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="s">"Click on screen"</span><span class="o">));</span>
            <span class="n">availableActions</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
        <span class="o">});</span>
        <span class="k">while</span><span class="o">(</span><span class="n">isAlive</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">doAction</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doAction</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">availableActions</span><span class="o">.</span><span class="na">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Runnable</span> <span class="n">currentAction</span> <span class="o">=</span> <span class="n">availableActions</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="n">currentAction</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
            <span class="n">availableActions</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">currentAction</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">availableActions</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Теперь наше приложение не отжирает все доступные ресурсы, а спокойно ждёт, пока придёт следующее действие, чтобы его обработать. Как только все доступные для выполнения действия заканчиваются оно засыпает, а когда происходит клик и появляется новое действие - оно просыпается.</p><h3 id="самый-главный-цикл-в-жизни-программы">Самый главный цикл в жизни программы</h3><p>Сам по себе подход с использованием цикла называется <a href="https://en.wikipedia.org/wiki/Event_loop" title="en.wikipedia.org">Event Loop</a> (если вам больше нравится на русском - <a href="https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB_%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9" title="ru.wikipedia.org">Цикл событий</a>). Если же <strong>Event Loop</strong> обеспечивает работу главного потока - то он уже «поднялся», он не какой-то простой <strong>Event Loop</strong>, он - <strong>Main Loop</strong> (Главный цикл). По сути он является ядром всего приложения, обеспечивая его работу. Весь код выполняемый на главном потоке (Main Thread) проходит через него. Практически все приложения в которых есть UI (и не только они) используют его.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/event-loop.png" alt="event loop" /></p><p>Вариантов реализации <strong>Main Loop</strong> множество, но нас сейчас интересует конкретно то - как это реализовано в Android. В целом у нас получился неплохой колхозный вариант <strong>Main Loop</strong>, но он не дает понимания всех нюансов работы главных циклов. Поэтому давайте вернёмся к коду на котором мы остановились и добавим немного комфортной городской среды в наш колхоз.</p><h3 id="распределяем-ответственности-по-классам">Распределяем ответственности по классам</h3><p>В целом у нас написано что-то похожее на рабочий код. Приложение само не закрывается, ждёт команд от пользователя и умеет их выполнять. Но как-то всё не по принципам <a href="https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="ru.wikipedia.org">SOLID</a>, особенно с буквой S (<a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%B5%D0%B4%D0%B8%D0%BD%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="ru.wikipedia.org">Single-Responsibility Principle</a>) большие проблемы. Вся логика в одном классе и ни о каком разделении ответственности речи идти не может. Давайте попытаемся это исправить, да и в целом хочется накинуть новых возможностей.</p><p>Для начала давайте сделаем обёртку над <code class="language-plaintext highlighter-rouge">Runnable</code> и назовем её… к примеру <code class="language-plaintext highlighter-rouge">Message</code>.</p><h4 id="message">Message</h4><p>Для этого просто создадим новый класс <code class="language-plaintext highlighter-rouge">Message</code>. Одним из полей которого как раз и будет наш <code class="language-plaintext highlighter-rouge">Runnable</code>. Назовем его <code class="language-plaintext highlighter-rouge">callback</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Message</span> <span class="o">{</span>
   <span class="nc">Runnable</span> <span class="n">callback</span><span class="o">;</span>
   <span class="kd">public</span> <span class="kt">long</span> <span class="n">when</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Дополнительно добавим еще одно поле <code class="language-plaintext highlighter-rouge">when</code>. Оно будет хранить значение времени в которое нужно выполнить действие. Ведь не всегда нужно выполнять что-то здесь и сейчас. Иногда, чтобы всё было хорошо, нужно подождать 500 миллисекунд. Для реализации такого механизма в поле <code class="language-plaintext highlighter-rouge">when</code> будет записываться время с момента старта приложения плюс время через которое должно произойти действие записанное в <code class="language-plaintext highlighter-rouge">callback</code>. Тоесть <code class="language-plaintext highlighter-rouge">when</code> = время с момента старта приложения + задержка для сообщения. Допустим я добавляю действие и хочу, чтобы оно выполнилось через 500 миллисекунд, а с момента старта приложения прошло 2000 миллисекунд, тогда в <code class="language-plaintext highlighter-rouge">when</code> у нас будет 2000 + 500 = 2500. Если же мне важно выполнить действие как можно скорее, то тогда в поле <code class="language-plaintext highlighter-rouge">when</code> надо записать 0.</p><p>Теперь давайте разберёмся с нашим <code class="language-plaintext highlighter-rouge">ArrayList</code>, который содержит действия.</p><h4 id="arraylist">ArrayList</h4><p>Тут сразу стоп!!! Мы ведь добавили поле <code class="language-plaintext highlighter-rouge">when</code>, тем самым позволяя создавать отложенные сообщения, а следовательно у нас появятся сообщения, которые могут находится в очереди очень долго ожидая своего часа.</p><p>Может сложиться следующая ситуация: у меня есть список из трёх сообщений, первые два должны выполняться как можно скорее, а третье… допустим через час. При этом первое сообщение добавляет ещё 10 сообщений в нашу очередь, каждое из которых должно выполняться как можно скорее. Это значит, что их надо добавить в очередь сразу после второго сообщения. Получается вставка в середину списка, а <a href="https://www.bigocheatsheet.com/" title="bigocheatsheet.com">как все знают</a> у <code class="language-plaintext highlighter-rouge">ArrayList</code> с операцией вставки есть проблемы.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/common-data-structure-operations.png" alt="common-data-structure-operations" /></p><p>Вставка в <code class="language-plaintext highlighter-rouge">ArrayList</code> имеет сложность <strong>O(n)</strong>, а значит, чем больше у нас будет сообщений в очереди, тем больше времени она будет занимать.</p><p>Поэтому хорошим решением будет заменить <code class="language-plaintext highlighter-rouge">ArrayList</code> на <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA" title="ru.wikipedia.org">связный список</a>, у которого сложность вставки <strong>O(1)</strong>, а значит количество элементов не будет влиять на время операции. Правда у связного списка есть проблемы с временем доступа к произвольному элементу, но это не касается первого элемента. А нам как раз нужен доступ только к первому элементу.</p><p>После того как сообщение выполнит свою работу, оно станет ненужным. Поэтому двусвязный список тут не очень подходит, ведь придётся каждый раз при удалении первого сообщения обращаться и ко второму, чтобы удалить ссылку на первое. А вот односвязный список - вполне подходит. Проблема только в том, что в Java нет стандартной реализации односвязного списка. Не беда! Сделаем сами. Для этого просто добавим поле <code class="language-plaintext highlighter-rouge">next</code> типа <code class="language-plaintext highlighter-rouge">Message</code> в сам <code class="language-plaintext highlighter-rouge">Message</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Message</span> <span class="o">{</span>
   <span class="nc">Runnable</span> <span class="n">callback</span><span class="o">;</span>
   <span class="kd">public</span> <span class="kt">long</span> <span class="n">when</span><span class="o">;</span>
   <span class="nc">Message</span> <span class="n">next</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Теперь у нас каждое сообщение содержит ссылку на следующее, таким образом формируя список. Если в поле <code class="language-plaintext highlighter-rouge">next</code> записан <code class="language-plaintext highlighter-rouge">null</code>, то это значит текущее сообщение является последним в списке.</p><p>Наш односвязный список готов и можно двигаться дальше.</p><h4 id="очередь-сообщений">Очередь сообщений</h4><p>Теперь бы надо где-то прописать логику работы с сообщениями. Для этого создадим новый класс. Пусть будет <code class="language-plaintext highlighter-rouge">MessageQueue</code>. Это конечно не Queue <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="ru.wikipedia.org">в прямом понимании этого типа</a>, так как у нас есть вставка в середину. С другой стороны - мы всегда берём для работы первое сообщение, так что называть класс <code class="language-plaintext highlighter-rouge">MessageList</code> еще более странная затея.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">MessageQueue</span> <span class="o">{</span>
   <span class="nc">Message</span> <span class="n">messages</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Пока в классе у нас будет единственное поле <code class="language-plaintext highlighter-rouge">messages</code> со ссылкой на начало списка сообщений, то есть ближайшее сообщение которое мы планируем обработать. Соответственно если поле <code class="language-plaintext highlighter-rouge">messages</code> = <code class="language-plaintext highlighter-rouge">null</code>, то список пустой, а значит новых сообщений нет.</p><h4 id="возвращаем-текущее-сообщение">Возвращаем текущее сообщение</h4><p>Теперь надо добавить метод который будет возвращать текущее сообщение. Для того, кто будет вызывать этот метод оно, по сути, будет следующим. Потому и назовем метод соответствующе - <code class="language-plaintext highlighter-rouge">next</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">MessageQueue</span> <span class="o">{</span>
   <span class="nc">Message</span> <span class="n">messages</span><span class="o">;</span>

   <span class="nc">Message</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
       <span class="nc">Message</span> <span class="n">current</span> <span class="o">=</span> <span class="n">messages</span><span class="o">;</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
       <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="n">messages</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
       <span class="o">}</span>
       <span class="k">return</span> <span class="n">current</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>В нём все просто:</p><ol><li>берём текущее сообщение<li>у него забираем ссылку на следующее за ним сообщение<li>делаем его текущим.</ol><p>Таким образом мы сделали текущим то сообщение, что было следующим, тем самым продвинув очередь. А то, что было текущим, возвращаем тому, кто вызвал этот метод.</p><p>Теперь нужно учесть, что сообщение имеет поле <code class="language-plaintext highlighter-rouge">when</code>, которое позволяет выполнить сообщение в указанное время, а значит сообщение не всегда нужно отдавать, оно ещё может быть не готово выполниться. Для этого добавим проверку сообщения по времени.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nc">Message</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
   <span class="nc">Message</span> <span class="n">current</span> <span class="o">=</span> <span class="n">messages</span><span class="o">;</span>

   <span class="kd">final</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">();</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
       <span class="n">messages</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
       <span class="k">return</span> <span class="n">current</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Для этого берём время которое прошло с момента старта приложения и записываем в переменную <code class="language-plaintext highlighter-rouge">now</code>. Далее просто сравниваем <code class="language-plaintext highlighter-rouge">now</code> и время, когда сообщение в переменной <code class="language-plaintext highlighter-rouge">current</code> должно выполниться. Если <code class="language-plaintext highlighter-rouge">now</code> меньше, то сообщаем тем кто вызвал метод, что следующего сообщения как будто бы и нет.</p><h4 id="новое-сообщение">Новое сообщение</h4><p>Получать следующее сообщение мы научились, теперь надо научиться добавлять новое. Для это создадим метод <code class="language-plaintext highlighter-rouge">enqueueMessage</code>, который добавляет новое сообщение.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">newMessage</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">newMessage</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="nc">Message</span> <span class="n">current</span> <span class="o">=</span> <span class="n">messages</span><span class="o">;</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">messages</span> <span class="o">=</span> <span class="n">newMessage</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
       <span class="nc">Message</span> <span class="n">previous</span><span class="o">;</span>
       <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
           <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
           <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
               <span class="k">break</span><span class="o">;</span>
           <span class="o">}</span>
       <span class="o">}</span>
       <span class="n">previous</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newMessage</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Внутри него сначала проверим есть ли у нас хоть одно запланированное действие. Если нет, то делаем новое сообщение первым в очереди. Если же есть, то пробежимся в цикле по нашей очереди, найдём последнее, то есть то, что имеет в поле <code class="language-plaintext highlighter-rouge">next</code> - <code class="language-plaintext highlighter-rouge">null</code> и добавим новое сообщение в самый конец, записав его в этот самый <code class="language-plaintext highlighter-rouge">next</code>.</p><p>Теперь нужно учесть, что <code class="language-plaintext highlighter-rouge">enqueueMessage</code> может вызываться с разных потоков, а это значит, что нам нужно синхронизировать добавление сообщений. Иначе может случиться плохая ситуация, когда два потока одновременно попробуют добавить сообщение и в лучшем случае мы получим потерю одного из сообщений, в худшем аварийное завершение программы.</p><p>Просто засунем код нашего метода в блок <code class="language-plaintext highlighter-rouge">synchronized</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">newMessage</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">newMessage</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">Message</span> <span class="n">current</span> <span class="o">=</span> <span class="n">messages</span><span class="o">;</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
           <span class="n">messages</span> <span class="o">=</span> <span class="n">newMessage</span><span class="o">;</span>
       <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
           <span class="nc">Message</span> <span class="n">previous</span><span class="o">;</span>
           <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
               <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
               <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                   <span class="k">break</span><span class="o">;</span>
               <span class="o">}</span>
           <span class="o">}</span>
           <span class="n">previous</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newMessage</span><span class="o">;</span>
       <span class="o">}</span>
   <span class="o">}</span>
   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>А так же добавим <code class="language-plaintext highlighter-rouge">synchronized</code> в метод <code class="language-plaintext highlighter-rouge">next</code>, так как он тоже обращается к <code class="language-plaintext highlighter-rouge">messages</code> и опять же может случиться нечто нехорошее.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nc">Message</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
   <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">Message</span> <span class="n">current</span> <span class="o">=</span> <span class="n">messages</span><span class="o">;</span>
       <span class="kd">final</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">();</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
           <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
       <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
           <span class="n">messages</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
           <span class="k">return</span> <span class="n">current</span><span class="o">;</span>
       <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Теперь нужно учесть, что мы можем добавить новое сообщение в середину очереди. Для этого добавим сравнение сообщений по полю <code class="language-plaintext highlighter-rouge">when</code> когда ищем последнее сообщение. То есть теперь мы ищем не просто сообщение, у которого <code class="language-plaintext highlighter-rouge">next</code> равен <code class="language-plaintext highlighter-rouge">null</code>, но так же и смотрим, чтобы у следующего сообщения значение <code class="language-plaintext highlighter-rouge">when</code> было меньше чем у нового. Ну и соответственно из-за вставки в середину нам нужно заполнить поле <code class="language-plaintext highlighter-rouge">next</code> у нового сообщения.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/adding-new-message.png" alt="adding-new-message" /></p><p>С точки зрения кода это будет выглядеть следующим образом:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">newMessage</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">newMessage</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">Message</span> <span class="n">current</span> <span class="o">=</span> <span class="n">messages</span><span class="o">;</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
           <span class="n">messages</span> <span class="o">=</span> <span class="n">newMessage</span><span class="o">;</span>
       <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
           <span class="nc">Message</span> <span class="n">previous</span><span class="o">;</span>
           <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
               <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
               <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">newMessage</span><span class="o">.</span><span class="na">when</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                   <span class="k">break</span><span class="o">;</span>
               <span class="o">}</span>
           <span class="o">}</span>
           <span class="n">newMessage</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">previous</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
           <span class="n">previous</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newMessage</span><span class="o">;</span>
       <span class="o">}</span>
   <span class="o">}</span>
   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>С очередью сообщений пока всё. Теперь пора переработать сам цикл.</p><h4 id="запускаем-цикл">Запускаем цикл</h4><p>Заводим новый класс и называем его <code class="language-plaintext highlighter-rouge">Looper</code>. В нём у нас содержится очередь сообщений (<code class="language-plaintext highlighter-rouge">MessageQueue</code>), переменная <code class="language-plaintext highlighter-rouge">isAlive</code>, которая отвечает за то, продолжать ли приложению работать, а также два метода:</p><ul><li><code class="language-plaintext highlighter-rouge">loop</code> - в котором запускается и крутится наш цикл<li><code class="language-plaintext highlighter-rouge">shutdown</code> - который переключает <code class="language-plaintext highlighter-rouge">isAlive</code> в <code class="language-plaintext highlighter-rouge">false</code>, тем самым останавливая обработку сообщений и завершая приложение.</ul><p>Давайте присмотримся к нашему основному методу <code class="language-plaintext highlighter-rouge">loop</code> поближе.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Looper</span> <span class="o">{</span>

   <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Looper</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Looper</span><span class="o">();</span>
   <span class="kd">final</span> <span class="nc">MessageQueue</span> <span class="n">messageQueue</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">isAlive</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nf">Looper</span><span class="o">()</span> <span class="o">{</span>
       <span class="n">messageQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MessageQueue</span><span class="o">();</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
       <span class="nc">Looper</span> <span class="n">currentInstance</span> <span class="o">=</span> <span class="n">instance</span><span class="o">;</span>
       <span class="k">while</span> <span class="o">(</span><span class="n">isAlive</span><span class="o">)</span> <span class="o">{</span>
           <span class="nc">Message</span> <span class="n">nextMessage</span> <span class="o">=</span> <span class="n">currentInstance</span><span class="o">.</span><span class="na">messageQueue</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">nextMessage</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span> <span class="o">{</span>
               <span class="n">nextMessage</span><span class="o">.</span><span class="na">callback</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
           <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
               <span class="k">try</span> <span class="o">{</span>
                  <span class="n">instance</span><span class="o">.</span><span class="na">messageQueue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
               <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
               <span class="o">}</span>
           <span class="o">}</span>
       <span class="o">}</span>
   <span class="o">}</span>


   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">isAlive</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>В нём мы получаем объект <code class="language-plaintext highlighter-rouge">Looper</code> и запускаем уже привычный нам бесконечный цикл, в котором запрашиваем новое сообщение у <code class="language-plaintext highlighter-rouge">MessageQueue</code>. Если сообщение есть, то выполняем действие, если же нет, то засыпаем.</p><p>Но уснуть то мы уснули, а когда же просыпаться? Нужно теперь куда-то добавить метод <code class="language-plaintext highlighter-rouge">notify</code>. По хорошему это надо делать там, где у нас добавляется новое сообщение, а происходит это внутри метода <code class="language-plaintext highlighter-rouge">MessageQueue.enqueueMessage</code>. Но вот засыпать в одном классе, а просыпаться в другом - идея так себе, ведь это будет сложно контролировать.</p><p>Также можно заметить, что мы не очень хорошо работаем с сообщениями которые собирались выполнить в определенное время и заполнили им поле <code class="language-plaintext highlighter-rouge">when</code>. Да, мы не выполним действие сообщения раньше времени за счёт проверки внутри <code class="language-plaintext highlighter-rouge">MessageQueue</code>, но мы можем проспать его выполнение, если у нас не будут поступать новые сообщения. Ведь спим мы пока не придёт новое сообщение и на самом деле маловероятно, что придёт оно именно в тот момент, когда надо будет выполнить сообщение по времени. Обе эти проблемы можно решить переносом ожидания нового сообщения внутрь <code class="language-plaintext highlighter-rouge">MessageQueue</code>.</p><h4 id="переносим-ожидание-в-messagequeue">Переносим ожидание в MessageQueue</h4><p>Давайте сделаем так, чтобы мы гарантированно отдавали сообщение в методе <code class="language-plaintext highlighter-rouge">next</code>, а если сообщения нет, то дожидаемся его.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="nc">Message</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
   <span class="kt">int</span> <span class="n">nextWaitTime</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
   <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">try</span> <span class="o">{</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">nextWaitTime</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">wait</span><span class="o">(</span><span class="n">nextWaitTime</span><span class="o">);</span>
           <span class="o">}</span>
       <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
       <span class="o">}</span>
       <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
           <span class="nc">Message</span> <span class="n">current</span> <span class="o">=</span> <span class="n">messages</span><span class="o">;</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
               <span class="kd">final</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">();</span>
               <span class="k">if</span> <span class="o">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                   <span class="n">nextWaitTime</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">when</span> <span class="o">-</span> <span class="n">now</span><span class="o">);</span>
               <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                   <span class="n">messages</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                   <span class="k">return</span> <span class="n">current</span><span class="o">;</span>
               <span class="o">}</span>
           <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
               <span class="n">nextWaitTime</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
           <span class="o">}</span>
       <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Также внутри метода <code class="language-plaintext highlighter-rouge">next</code> появился цикл, который отвечает за ожидание сообщения. В нём мы проверяем есть ли сообщения, если нет - то спим пока не вызовут <code class="language-plaintext highlighter-rouge">notify</code>. Если есть, то смотрим нужно ли сейчас выполнять действие текущего сообщения. Если да, то возвращаем сообщение, если же нет, то засыпаем пока не придёт время выполнить действие текущего сообщения.</p><p>В метод <code class="language-plaintext highlighter-rouge">enqueueMessage</code> же добавим вызов <code class="language-plaintext highlighter-rouge">notify</code>, чтобы пробудить наш цикл в методе <code class="language-plaintext highlighter-rouge">next</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">newMessage</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">newMessage</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">Message</span> <span class="n">current</span> <span class="o">=</span> <span class="n">messages</span><span class="o">;</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
           <span class="n">messages</span> <span class="o">=</span> <span class="n">newMessage</span><span class="o">;</span>
       <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
           <span class="nc">Message</span> <span class="n">previous</span><span class="o">;</span>
           <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
               <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
               <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">newMessage</span><span class="o">.</span><span class="na">when</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                   <span class="k">break</span><span class="o">;</span>
               <span class="o">}</span>
           <span class="o">}</span>
           <span class="n">newMessage</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">previous</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
           <span class="n">previous</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newMessage</span><span class="o">;</span>
       <span class="o">}</span>
       <span class="n">notify</span><span class="o">();</span>
   <span class="o">}</span>
   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Ну и напоследок в самом <code class="language-plaintext highlighter-rouge">Looper</code> уберём ожидание. Теперь он просто выполняет действия сообщений.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
   <span class="nc">Looper</span> <span class="n">currentInstance</span> <span class="o">=</span> <span class="n">instance</span><span class="o">;</span>
   <span class="k">while</span> <span class="o">(</span><span class="n">isAlive</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">Message</span> <span class="n">nextMessage</span> <span class="o">=</span> <span class="n">currentInstance</span><span class="o">.</span><span class="na">messageQueue</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
       <span class="n">nextMessage</span><span class="o">.</span><span class="na">callback</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="общая-схема">Общая схема</h3><p>Общая логика работы получилась такой:</p><ol><li>Система запускает наш процесс, что в итоге ведёт к вызову метода <code class="language-plaintext highlighter-rouge">loop</code> у <code class="language-plaintext highlighter-rouge">Looper</code>.<li><code class="language-plaintext highlighter-rouge">Looper</code> внутри себя обращается к методу <code class="language-plaintext highlighter-rouge">next</code> у <code class="language-plaintext highlighter-rouge">MessageQueue</code> за новым сообщением.<li><code class="language-plaintext highlighter-rouge">MessageQueue</code> видя, что сообщений пока нет - останавливает текущий поток с помощью метода <code class="language-plaintext highlighter-rouge">wait</code>.<li>Система кидает нам какое-нибудь событие, например клик на экран, что в итоге добавляет новое сообщение в нашу очередь сообщений через метод <code class="language-plaintext highlighter-rouge">enqueueMessage</code> у <code class="language-plaintext highlighter-rouge">MessageQueue</code> и будит текущий поток.<li>Метод <code class="language-plaintext highlighter-rouge">next</code> у <code class="language-plaintext highlighter-rouge">MessageQueue</code> просыпается и видит что у него появилось новое сообщение.<li>Это новое сообщение <code class="language-plaintext highlighter-rouge">MessageQueue</code> возвращается в <code class="language-plaintext highlighter-rouge">Looper</code>.<li><code class="language-plaintext highlighter-rouge">Looper</code> просто выполняет <code class="language-plaintext highlighter-rouge">callback</code> из сообщения.<li>Обратно к пункту 2.</ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/main-loop-scheme.png" alt="main-loop-scheme" /></p><p>Отлично! В итоге у нас вполне рабочий цикл событий. Даже что-то близкое к тому, как все устроено в Android, но в Android классах кода куда больше. Например, в нашем <code class="language-plaintext highlighter-rouge">Looper</code> 25 строк, а в <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/os/Looper.java" title="android.googlesource.com">Android 493</a>, правда это с учётом JavaDoc. Всё потому, что <code class="language-plaintext highlighter-rouge">Looper</code>, <code class="language-plaintext highlighter-rouge">Message</code>, <code class="language-plaintext highlighter-rouge">MessageQueue</code> обладают в Android SDK дополнительными возможностями.</p><hr /><h2 id="android-sdk">Android SDK</h2><p>Разобравшися с тем, что такое главный цикл и как он работает, давайте теперь разберёмся как <strong>Main Loop</strong> устроен в Android SDK. Разбираться будем в контексте Android SDK версии 30.</p><h3 id="looper">Looper</h3><p>Начнём мы с самого главного - <code class="language-plaintext highlighter-rouge">Looper</code>. Напомню, что этот класс отвечает за сам цикл и его работу. Далее в рассуждениях я буду отталкиваться от того, что вы прочли первую часть и/или понимаете общую логику работы главного цикла. Приступим.</p><h4 id="может-быть-создан-для-любого-из-потоков-и-только-один">Может быть создан для любого из потоков и только один</h4><p>Первое, что бросается в глаза - приватный конструктор.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="nf">Looper</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">mQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MessageQueue</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">);</span>
   <span class="n">mThread</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Создать <code class="language-plaintext highlighter-rouge">Looper</code> можно только используя метод <code class="language-plaintext highlighter-rouge">prepare</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Looper</span><span class="o">&gt;</span> <span class="n">sThreadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Looper</span><span class="o">&gt;();</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">()</span> <span class="o">{</span>
   <span class="n">prepare</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">sThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Only one Looper may be created per thread"</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="n">sThreadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">new</span> <span class="nc">Looper</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">));</span>
<span class="o">}</span>
</pre></table></code></div></div><p>При вызове публичного метода <code class="language-plaintext highlighter-rouge">prepare</code> вызывается его приватная реализация. Она принимает в себя параметр <code class="language-plaintext highlighter-rouge">quitAllowed</code>. Он будет <code class="language-plaintext highlighter-rouge">true</code>, если для данного <code class="language-plaintext highlighter-rouge">Looper</code> есть возможность завершиться во время работы приложения. Для главного потока этот параметр всегда будет <code class="language-plaintext highlighter-rouge">false</code>, так как если завершится главный поток, то завершится и приложение. Для побочных же потоков этот параметр всегда равен <code class="language-plaintext highlighter-rouge">true</code>.</p><p>Также в методе <code class="language-plaintext highlighter-rouge">prepare</code> можно заметить обращение к полю <code class="language-plaintext highlighter-rouge">sThreadLocal</code> типа <code class="language-plaintext highlighter-rouge">ThreadLocal</code>. Что же это такое?</p><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html" title="docs.oracle.com"><code class="language-plaintext highlighter-rouge">ThreadLocal</code></a> это такое хранилище, в котором для каждого из потоков будет хранится свое значение. Допустим я из потока 1 кладу в это хранилище <code class="language-plaintext highlighter-rouge">true</code>, затем если я обращусь из этого же потока к хранилищу - я получу <code class="language-plaintext highlighter-rouge">true</code>. Но если я обращусь к этому хранилищу из другого потока, то мне вернется <code class="language-plaintext highlighter-rouge">null</code>, так как для этого потока значение еще не было записано.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/thread-local.png" alt="thread-local" /></p><p><code class="language-plaintext highlighter-rouge">Looper</code> использует этот механизм вкупе с приватным конструктором для того, чтобы обеспечить уникальность <code class="language-plaintext highlighter-rouge">Looper</code> для каждого из потоков. Внутри метода <code class="language-plaintext highlighter-rouge">prepare</code> с помощью <code class="language-plaintext highlighter-rouge">ThreadLocal</code> он сначала проверяет был ли уже создан <code class="language-plaintext highlighter-rouge">Looper</code> для текущего потока, если это так, то бросает исключение которое скажет о том, что негоже создавать несколько <code class="language-plaintext highlighter-rouge">Looper</code> для одного потока. Если же <code class="language-plaintext highlighter-rouge">Looper</code> для текущего потока еще не был создан, то он создает новый <code class="language-plaintext highlighter-rouge">Looper</code> и сразу же записывает его в <code class="language-plaintext highlighter-rouge">ThreadLocal</code>.</p><p>Для получения экземпляра <code class="language-plaintext highlighter-rouge">Looper</code>, созданного в методе <code class="language-plaintext highlighter-rouge">prepare</code>, есть метод <code class="language-plaintext highlighter-rouge">myLooper</code>. Он просто каждый раз обращается к <code class="language-plaintext highlighter-rouge">sThreadLocal</code> для получения значения для текущего потока.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">Looper</span> <span class="nf">myLooper</span><span class="o">()</span> <span class="o">{</span>
   <span class="k">return</span> <span class="n">sThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>С такой логикой <code class="language-plaintext highlighter-rouge">Looper</code> можно создать для любого из потоков, пользоваться и при этом точно знать, что для данного потока <code class="language-plaintext highlighter-rouge">Looper</code> только один. Допустим у нас есть 5 потоков и каждый из них создает и обращается к <code class="language-plaintext highlighter-rouge">Looper</code>. В итоге у нас будет создано 5 экземпляров <code class="language-plaintext highlighter-rouge">Looper</code>, но при обращении к <code class="language-plaintext highlighter-rouge">Looper.myLooper</code> каждый из потоков будет получать свой уникальный экземпляр.</p><h4 id="главный-среди-равных">Главный среди равных</h4><p>Правда тут появляется вопрос - если <code class="language-plaintext highlighter-rouge">Looper</code> может быть несколько, то какой из них является главным циклом? Ведь я могу создать несколько потоков, для каждого из них создать <code class="language-plaintext highlighter-rouge">Looper</code>, то как потом другим программистам понять кто же из них главный и куда им слать сообщения? Создатели Android подумали так же. Поэтому в <code class="language-plaintext highlighter-rouge">Looper</code> есть следующий код:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="nc">Looper</span> <span class="n">sMainLooper</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepareMainLooper</span><span class="o">()</span> <span class="o">{</span>
   <span class="n">prepare</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
   <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Looper</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">sMainLooper</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"The main Looper has already been prepared."</span><span class="o">);</span>
       <span class="o">}</span>
       <span class="n">sMainLooper</span> <span class="o">=</span> <span class="n">myLooper</span><span class="o">();</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Looper</span> <span class="nf">getMainLooper</span><span class="o">()</span> <span class="o">{</span>
   <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Looper</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">sMainLooper</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Отдельный метод <code class="language-plaintext highlighter-rouge">prepareMainLooper</code> как раз занимается тем, что создаёт <code class="language-plaintext highlighter-rouge">Looper</code> для текущего потока и записывает его в отдельное статическое поле <code class="language-plaintext highlighter-rouge">sMainLooper</code>, тем самым как-бы объявляя его главным. Теперь если кто-то попробует вызвать <code class="language-plaintext highlighter-rouge">prepareMainLooper</code> с другого потока, то будет брошено исключение, которое скажет нам, что главный вообще-то может быть только один.</p><p>Ещё у главного потока есть свой отдельный getter - <code class="language-plaintext highlighter-rouge">getMainLooper</code>, ведь обращение к главному циклу может понадобиться где угодно. Таким образом, разработчики всегда будут знать кто тут главный <code class="language-plaintext highlighter-rouge">Looper</code>.</p><p>Теперь давайте ближе взглянем на особенности самого цикла, а значит на метод <code class="language-plaintext highlighter-rouge">loop</code>.</p><h4 id="логирование">Логирование</h4><p>Первое что бросается в глаза в методе <code class="language-plaintext highlighter-rouge">loop</code>, это то, что у нас вместо цикла <code class="language-plaintext highlighter-rouge">while</code> используется <code class="language-plaintext highlighter-rouge">for</code> с двумя точками с запятой. Такой подход <a href="https://techdifferences.com/differenece-between-for-and-while-loop.html" title="techdifferences.com">вроде как</a> производительнее.</p><p>Также можно заметить, что остановка бесконечного цикла делается не с помощью переключения отдельной переменной <code class="language-plaintext highlighter-rouge">isAlive</code>, а с помощью получения <code class="language-plaintext highlighter-rouge">null</code> от <code class="language-plaintext highlighter-rouge">MessageQueue.next</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
  <span class="o">..................</span>

  <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
      <span class="nc">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Куда более интересное отличие, что в <code class="language-plaintext highlighter-rouge">Looper</code> из Android SDK у нас появляется логирование. Для него используется класс под названием <code class="language-plaintext highlighter-rouge">Printer</code>. По сути его единственной функцией является вывод сообщения с помощью метода <code class="language-plaintext highlighter-rouge">println</code>.</p><p>Инициализированный объект <code class="language-plaintext highlighter-rouge">Printer</code> хранится в поле <code class="language-plaintext highlighter-rouge">mLogging</code>, то есть у каждого из <code class="language-plaintext highlighter-rouge">Looper</code> может быть свой личный <code class="language-plaintext highlighter-rouge">Printer</code>. Выставляется <code class="language-plaintext highlighter-rouge">Printer</code> через отдельный сеттер. Если же <code class="language-plaintext highlighter-rouge">Printer</code> не задать, то и логирования не будет.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="nc">Printer</span> <span class="n">mLogging</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMessageLogging</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Printer</span> <span class="n">printer</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">mLogging</span> <span class="o">=</span> <span class="n">printer</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Внутри самого метода <code class="language-plaintext highlighter-rouge">loop</code> <code class="language-plaintext highlighter-rouge">Printer</code> используется трижды:</p><ul><li>в первый раз когда мы принимаем сообщение. Ссылка из поля <code class="language-plaintext highlighter-rouge">mLogging</code> записывается в <code class="language-plaintext highlighter-rouge">final</code> переменную <code class="language-plaintext highlighter-rouge">logging</code>. Это нужно, чтобы не было ситуаций когда во время обработки сообщения мы сменили <code class="language-plaintext highlighter-rouge">Printer</code> в поле <code class="language-plaintext highlighter-rouge">mLogging</code> и логирование по одному сообщению произошло в разные места;<li>во второй раз когда он сообщает нам о том, что началась обработка сообщения и выводит информацию о самом сообщении;<li>в третий раз когда он сообщает нам о том, что обработка сообщения завершена и выводит информацию о самом сообщении.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">final</span> <span class="nc">Printer</span> <span class="n">logging</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="na">mLogging</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">logging</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">logging</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span>
           <span class="n">msg</span><span class="o">.</span><span class="na">callback</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="na">what</span><span class="o">);</span>
<span class="o">}</span>
<span class="o">..................</span>
<span class="k">if</span> <span class="o">(</span><span class="n">logging</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">logging</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="na">callback</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Но логирование не является единственным способом отслеживания работы <code class="language-plaintext highlighter-rouge">Looper</code>. Дополнительно используется класс <code class="language-plaintext highlighter-rouge">Trace</code>. Он нужен для трассировки стека методов через <code class="language-plaintext highlighter-rouge">SysTrace</code>. С помощью <code class="language-plaintext highlighter-rouge">SysTrace</code> мы в <code class="language-plaintext highlighter-rouge">Profiler</code> из Android Studio можем просматривать этот самый стек и время исполнения каждого из методов в нем. Для этого, перед тем как начнет обрабатываться новое сообщение вызывается <code class="language-plaintext highlighter-rouge">Trace.traceBegin</code> и когда обработка сообщения завершится <code class="language-plaintext highlighter-rouge">Trace.traceEnd</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">traceTag</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nc">Trace</span><span class="o">.</span><span class="na">isTagEnabled</span><span class="o">(</span><span class="n">traceTag</span><span class="o">))</span> <span class="o">{</span>
   <span class="nc">Trace</span><span class="o">.</span><span class="na">traceBegin</span><span class="o">(</span><span class="n">traceTag</span><span class="o">,</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">getTraceName</span><span class="o">(</span><span class="n">msg</span><span class="o">));</span>
<span class="o">}</span>
<span class="o">..................</span>
<span class="k">if</span> <span class="o">(</span><span class="n">traceTag</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
   <span class="nc">Trace</span><span class="o">.</span><span class="na">traceEnd</span><span class="o">(</span><span class="n">traceTag</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Но это ещё не все методы слежки.</p><h4 id="подсчёт-времени">Подсчёт времени</h4><p><code class="language-plaintext highlighter-rouge">Looper</code> считает время доставки и обработки сообщений и если это время больше ожидаемого, то он сообщит нам об этом. Это может понадобиться в поисках источников фризов и лагов. Допустим у нас экран 60 Гц, значит желательно, чтобы каждое сообщение обрабатывалось не более 1000 / 60 = 16,6 мс (на самом деле нужно меньше, но не суть), иначе главный поток не успеет подготовить данные для отрисовки и у нас используется прошлый кадр. Из-за этого будет казаться будто бы изображение зависло, а значит интерфейс перестанет быть плавным.</p><p>Для этого у нас имеется два поля типа <code class="language-plaintext highlighter-rouge">long</code>: <code class="language-plaintext highlighter-rouge">mSlowDeliveryThresholdMs</code>, отвечающий за время доставки сообщения, и <code class="language-plaintext highlighter-rouge">mSlowDispatchThresholdMs</code>, отвечающий за время обработки сообщения.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">long</span> <span class="n">mSlowDispatchThresholdMs</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">long</span> <span class="n">mSlowDeliveryThresholdMs</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSlowLogThresholdMs</span><span class="o">(</span><span class="kt">long</span> <span class="n">slowDispatchThresholdMs</span><span class="o">,</span> <span class="kt">long</span> <span class="n">slowDeliveryThresholdMs</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">mSlowDispatchThresholdMs</span> <span class="o">=</span> <span class="n">slowDispatchThresholdMs</span><span class="o">;</span>
   <span class="n">mSlowDeliveryThresholdMs</span> <span class="o">=</span> <span class="n">slowDeliveryThresholdMs</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Выставляем <code class="language-plaintext highlighter-rouge">mSlowDispatchThresholdMs</code> равным 16 и <code class="language-plaintext highlighter-rouge">Looper</code> сам будет уведомлять нас о всех сообщениях которые обрабатывались дольше этого времени и соответственно являются причиной подвисания.</p><p>Для выставления значений этих полей создан отдельный метод <code class="language-plaintext highlighter-rouge">setSlowLogThresholdMs</code>. Эти поля всегда выставляются парой.</p><p>Также есть возможность задать это время с помощью системной переменной. Имя которой формируется по следующему принципу: <code class="language-plaintext highlighter-rouge">log.looper.&lt;”идентификатор процесса”&gt;.&lt;”имя потока, в нашем случае это будет main”&gt;.slow</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">final</span> <span class="kt">int</span> <span class="n">thresholdOverride</span> <span class="o">=</span>
       <span class="nc">SystemProperties</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="s">"log.looper."</span>
               <span class="o">+</span> <span class="nc">Process</span><span class="o">.</span><span class="na">myUid</span><span class="o">()</span> <span class="o">+</span> <span class="s">"."</span>
               <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span>
               <span class="o">+</span> <span class="s">".slow"</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</pre></table></code></div></div><p>Теперь посмотрим как это всё работает внутри метода <code class="language-plaintext highlighter-rouge">loop</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">long</span> <span class="n">slowDispatchThresholdMs</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="na">mSlowDispatchThresholdMs</span><span class="o">;</span>
<span class="kt">long</span> <span class="n">slowDeliveryThresholdMs</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="na">mSlowDeliveryThresholdMs</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">thresholdOverride</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">slowDispatchThresholdMs</span> <span class="o">=</span> <span class="n">thresholdOverride</span><span class="o">;</span>
   <span class="n">slowDeliveryThresholdMs</span> <span class="o">=</span> <span class="n">thresholdOverride</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="n">logSlowDelivery</span> <span class="o">=</span> <span class="o">(</span><span class="n">slowDeliveryThresholdMs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="n">logSlowDispatch</span> <span class="o">=</span> <span class="o">(</span><span class="n">slowDispatchThresholdMs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>

<span class="kd">final</span> <span class="kt">boolean</span> <span class="n">needStartTime</span> <span class="o">=</span> <span class="n">logSlowDelivery</span> <span class="o">||</span> <span class="n">logSlowDispatch</span><span class="o">;</span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="n">needEndTime</span> <span class="o">=</span> <span class="n">logSlowDispatch</span><span class="o">;</span>
</pre></table></code></div></div><p>Выглядит как-то путано, не правда ли? Сначала значение полей записываются в локальные переменные. Затем проверяется, не было ли задано ограничение с помощью системной переменной, если это так, то берётся именно оно. Если оба значения для времени доставки и обработки больше нуля, то метод <code class="language-plaintext highlighter-rouge">loop</code> понимает, что время начать считать.</p><p>Далее формируются два значения: начала и окончания. Если с обработкой всё понятно, то для подсчёта времени доставки в качестве времени начала выступает ожидаемое время начала обработки, а в качестве времени окончания используется время реального начала обработки.</p><p>После того как обработка сообщения завершится вызывается статический метод <code class="language-plaintext highlighter-rouge">showSlowLog</code> отдельно для времени доставки и отдельно для времени обработки.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">showSlowLog</span><span class="o">(</span>
  <span class="kt">long</span> <span class="n">threshold</span><span class="o">,</span>
  <span class="kt">long</span> <span class="n">measureStart</span><span class="o">,</span>
  <span class="kt">long</span> <span class="n">measureEnd</span><span class="o">,</span>
  <span class="nc">String</span> <span class="n">what</span><span class="o">,</span>
  <span class="nc">Message</span> <span class="n">msg</span>
<span class="o">)</span> <span class="o">{</span>
   <span class="kd">final</span> <span class="kt">long</span> <span class="n">actualTime</span> <span class="o">=</span> <span class="n">measureEnd</span> <span class="o">-</span> <span class="n">measureStart</span><span class="o">;</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">actualTime</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="nc">Slog</span><span class="o">.</span><span class="na">w</span><span class="o">(</span><span class="no">TAG</span><span class="o">,</span> <span class="s">"Slow "</span> <span class="o">+</span> <span class="n">what</span> <span class="o">+</span> <span class="s">" took "</span> <span class="o">+</span> <span class="n">actualTime</span> <span class="o">+</span> <span class="s">"ms "</span>
           <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" h="</span>
           <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" c="</span> <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="na">callback</span> <span class="o">+</span> <span class="s">" m="</span> <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="na">what</span><span class="o">);</span>
   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>В самом методе всё довольно просто - из времени окончания вычитается время начала, таким образом получается длительность обработки или доставки. Если эта длительность больше чем ожидаемая, то происходит вывод в лог информации о сообщении.</p><p>Интересный момент тут в том, что логирование происходит с помощью класса <code class="language-plaintext highlighter-rouge">Slog</code>, а не обычного <code class="language-plaintext highlighter-rouge">Log</code>. <code class="language-plaintext highlighter-rouge">Slog</code> - это специальный класс, который выводит логи от имени системы. Так что, имейте ввиду, что если установить фильтр по имени вашего процесса в <code class="language-plaintext highlighter-rouge">logcat</code>, то вы не увидите этих сообщений.</p><h4 id="наблюдатели-и-trycatch">Наблюдатели и try/catch</h4><p>И это ещё не все способы наблюдения за <code class="language-plaintext highlighter-rouge">Looper</code>. До этого информация выводилась либо в лог, либо в <code class="language-plaintext highlighter-rouge">SysTrace</code>. Но что если надо следить за <code class="language-plaintext highlighter-rouge">Looper</code> прямо в коде? Для этого используется внутренний <code class="language-plaintext highlighter-rouge">interface</code> <code class="language-plaintext highlighter-rouge">Looper</code> - <code class="language-plaintext highlighter-rouge">Observer</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Observer</span> <span class="o">{</span>

   <span class="nc">Object</span> <span class="nf">messageDispatchStarting</span><span class="o">();</span>

   <span class="kt">void</span> <span class="nf">messageDispatched</span><span class="o">(</span><span class="nc">Object</span> <span class="n">token</span><span class="o">,</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">);</span>

   <span class="kt">void</span> <span class="nf">dispatchingThrewException</span><span class="o">(</span><span class="nc">Object</span> <span class="n">token</span><span class="o">,</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">exception</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Он содержит в себе методы наблюдения за стартом обработки сообщения, за окончанием обработки сообщения и за вероятным исключением при обработке сообщения. Последний метод может понадобиться, чтобы как-то использовать исключение, которое привело к падению приложения, например, отправить информацию о нём на удалённый сервер, как это делает Firebase Crashlytics.</p><p>Сам <code class="language-plaintext highlighter-rouge">Observer</code> хранится статической переменной <code class="language-plaintext highlighter-rouge">sObserver</code>, то есть наблюдатель выставляется сразу для всех экземпляров <code class="language-plaintext highlighter-rouge">Looper</code>. Выставляется он через отдельный сеттер.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="nc">Observer</span> <span class="n">sObserver</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setObserver</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Observer</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">sObserver</span> <span class="o">=</span> <span class="n">observer</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Сама логика вызова методов <code class="language-plaintext highlighter-rouge">Observer</code> довольно простая.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="nc">Object</span> <span class="n">token</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">observer</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">token</span> <span class="o">=</span> <span class="n">observer</span><span class="o">.</span><span class="na">messageDispatchStarting</span><span class="o">();</span>
<span class="o">}</span>
<span class="kt">long</span> <span class="n">origWorkSource</span> <span class="o">=</span> <span class="nc">ThreadLocalWorkSource</span><span class="o">.</span><span class="na">setUid</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">workSourceUid</span><span class="o">);</span>
<span class="k">try</span> <span class="o">{</span>
   <span class="n">msg</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">dispatchMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">observer</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">observer</span><span class="o">.</span><span class="na">messageDispatched</span><span class="o">(</span><span class="n">token</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="n">dispatchEnd</span> <span class="o">=</span> <span class="n">needEndTime</span> <span class="o">?</span> <span class="nc">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">observer</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">observer</span><span class="o">.</span><span class="na">dispatchingThrewException</span><span class="o">(</span><span class="n">token</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span> <span class="n">exception</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="k">throw</span> <span class="n">exception</span><span class="o">;</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
   <span class="nc">ThreadLocalWorkSource</span><span class="o">.</span><span class="na">restore</span><span class="o">(</span><span class="n">origWorkSource</span><span class="o">);</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">traceTag</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">Trace</span><span class="o">.</span><span class="na">traceEnd</span><span class="o">(</span><span class="n">traceTag</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>В момент обработки сообщения внутри метода <code class="language-plaintext highlighter-rouge">loop</code> проверяется - есть ли сейчас наблюдатель, если наблюдатель имеется, то у него вызывается метод <code class="language-plaintext highlighter-rouge">messageDispatchStarting</code>. Методы <code class="language-plaintext highlighter-rouge">messageDispatched</code> и <code class="language-plaintext highlighter-rouge">dispatchingThrewException</code> вызываются в соответствующих местах.</p><p>Можно заметить, что обработка сообщения обёрнута в <code class="language-plaintext highlighter-rouge">try-catch-finally</code>. Это необходимо, чтобы в случае ошибки правильно отработали методы трассировки <code class="language-plaintext highlighter-rouge">SysTrace</code>, а так же вызов метода <code class="language-plaintext highlighter-rouge">dispatchingThrewException</code> у наблюдателя. И лишь потом будет брошено исключение, которое и завершит наше приложение.</p><p>Это пожалуй все интересные особенности класса <code class="language-plaintext highlighter-rouge">Looper</code> в Android SDK.</p><h3 id="activitythread">ActivityThread</h3><p>Теперь давайте рассмотрим, где же всё-таки у нас идёт работа с самим <code class="language-plaintext highlighter-rouge">Looper</code>. А происходит это всё также в методе <code class="language-plaintext highlighter-rouge">main</code> и находится он в классе <code class="language-plaintext highlighter-rouge">ActivityThread</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
   <span class="o">..................</span>
   <span class="nc">Looper</span><span class="o">.</span><span class="na">prepareMainLooper</span><span class="o">();</span>
   <span class="o">..................</span>
   <span class="k">if</span> <span class="o">(</span><span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">Looper</span><span class="o">.</span><span class="na">myLooper</span><span class="o">().</span><span class="na">setMessageLogging</span><span class="o">(</span><span class="k">new</span>
               <span class="nc">LogPrinter</span><span class="o">(</span><span class="nc">Log</span><span class="o">.</span><span class="na">DEBUG</span><span class="o">,</span> <span class="s">"ActivityThread"</span><span class="o">));</span>
   <span class="o">}</span>
   <span class="o">..................</span>
   <span class="nc">Looper</span><span class="o">.</span><span class="na">loop</span><span class="o">();</span>

   <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Main thread loop unexpectedly exited"</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>В нём сначала вызывается метод <code class="language-plaintext highlighter-rouge">prepareMainLooper</code>. Далее выставляется реализация <code class="language-plaintext highlighter-rouge">Printer</code>. И под самый конец метода вызывается метод <code class="language-plaintext highlighter-rouge">loop</code>, запускающий главный цикл. Последней строкой этого метода бросается исключение. Таким образом, как только цикл завершится, то и завершится весь процесс.</p><p>Если хотите поподробнее узнать о том как запускается процесс в андроид, то рекомендую посмотреть эту <a href="https://habr.com/ru/post/345120/" title="habr.com">статью</a>.</p><h3 id="messagequeue">MessageQueue</h3><p>Теперь рассмотрим какими особенностями обладает <code class="language-plaintext highlighter-rouge">MessageQueue</code> - класс? отвечающий за работу очереди сообщений в Android SDK.</p><h4 id="main-thread-не-ждет">Main Thread не ждет</h4><p>Первая особенность <code class="language-plaintext highlighter-rouge">MessageQueue</code> заключается в том, что вместо стандартных методов из Java <code class="language-plaintext highlighter-rouge">wait</code> и <code class="language-plaintext highlighter-rouge">notify</code> используются нативные методы <code class="language-plaintext highlighter-rouge">nativePollOnce</code> и <code class="language-plaintext highlighter-rouge">nativeWake</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">long</span> <span class="n">mPtr</span><span class="o">;</span>

<span class="kd">private</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">nativePollOnce</span><span class="o">(</span><span class="kt">long</span> <span class="n">ptr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timeoutMillis</span><span class="o">);</span>
<span class="kd">private</span> <span class="kd">native</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">nativeWake</span><span class="o">(</span><span class="kt">long</span> <span class="n">ptr</span><span class="o">);</span>

<span class="nc">Message</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">..................</span>
    <span class="n">nativePollOnce</span><span class="o">(</span><span class="n">mPtr</span><span class="o">,</span> <span class="n">nextPollTimeoutMillis</span><span class="o">);</span>
    <span class="o">..................</span>
<span class="o">}</span>

<span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">..................</span>
    <span class="n">nativeWake</span><span class="o">(</span><span class="n">mPtr</span><span class="o">);</span>
    <span class="o">..................</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Когда мы пытаемся запросить следующее сообщение и его не оказывается, то вместо <code class="language-plaintext highlighter-rouge">wait</code> вызывается <code class="language-plaintext highlighter-rouge">nativePollOnce</code>, в который передаётся время, на которое надо уснуть.</p><p>Когда мы пытаемся добавить новое сообщение, у нас вместо метода <code class="language-plaintext highlighter-rouge">notify</code> вызывается метод <code class="language-plaintext highlighter-rouge">nativeWake</code>.</p><p>Почему же нельзя воспользоваться обычными <code class="language-plaintext highlighter-rouge">wait</code> и <code class="language-plaintext highlighter-rouge">notify</code>? Дело в том, что у Android приложений помимо Java слоя есть ещё и прослойка C++, в которой на главном потоке тоже могут происходить различные операции, которые стоит выполнить. Следовательно воспользоваться <code class="language-plaintext highlighter-rouge">wait</code> у нас не получится, так как это усыпит главный поток без передачи управления прослойке C++.</p><p>В прослойке C++ так же есть свой <code class="language-plaintext highlighter-rouge">Looper</code>, но подробнее мы разберём его в следующей статье.</p><p>Вызов C++ конечно интересен сам по себе, но есть в <code class="language-plaintext highlighter-rouge">MessageQueue</code> что-то, что может пригодиться обычному разработчику? Конечно есть.</p><h4 id="idlehandler">IdleHandler</h4><p>Это особый механизм, который позволяет выполнять какие-либо действия на главном потоке, когда все сообщения из очереди будут выполнены. Он хорошо подходит для действий, которым неважно, когда они будут выполнены - сейчас или через пол секунды. С помощью этого механизма можно избавиться от некоторых фризов, убрав какое-то тяжёлое или не очень действие из основной очереди сообщений.</p><p>Например, <a href="https://habr.com/ru/company/vk/blog/501988/" title="habr.com">в приложении VK отметка о том, что сообщение прочли, выставляется именно таким образом</a>, а <a href="https://habr.com/ru/company/cian/blog/576732/" title="habr.com">в ЦИАН <code class="language-plaintext highlighter-rouge">IdleHadler</code> используется для тяжёлых действий при работе с картой</a>.</p><p>Давайте посмотрим на реализацию этого механизма. По своей сути <code class="language-plaintext highlighter-rouge">IdleHandler</code> - это обычный интерфейс с одним единственным методом - <code class="language-plaintext highlighter-rouge">queueIdle</code>. В нём и будет содержаться действие, которое мы планируем выполнить.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kd">interface</span> <span class="nc">IdleHandler</span> <span class="o">{</span>
   <span class="kt">boolean</span> <span class="nf">queueIdle</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Как можно заметить, этот метод возвращает <code class="language-plaintext highlighter-rouge">boolean</code>. Если вернуть <code class="language-plaintext highlighter-rouge">false</code>, то наше действие больше не повторится, если же вернуть <code class="language-plaintext highlighter-rouge">true</code> - то наше действие выполнится ещё раз. Поэтому лучше лишний раз не ставить <code class="language-plaintext highlighter-rouge">true</code>, дабы избежать ситуаций, когда у нас появляется бесконечно повторяющееся действие на главном потоке.</p><p>В классе <code class="language-plaintext highlighter-rouge">MessageQueue</code> в поле <code class="language-plaintext highlighter-rouge">mIdleHandlers</code> находится список ещё не выполненных <code class="language-plaintext highlighter-rouge">IdleHandler</code>, а также есть метод для добавления нового <code class="language-plaintext highlighter-rouge">IdleHandler</code> - <code class="language-plaintext highlighter-rouge">addIdleHandler</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">final</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">IdleHandler</span><span class="o">&gt;</span> <span class="n">mIdleHandlers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">IdleHandler</span><span class="o">&gt;();</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">addIdleHandler</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">IdleHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">handler</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">(</span><span class="s">"Can't add a null IdleHandler"</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">mIdleHandlers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">handler</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Единственной особенностью <code class="language-plaintext highlighter-rouge">addIdleHandler</code> является синхронизация.</p><p>Теперь надо как-то узнать, что основная очередь сообщений опустела и настало время выполнения <code class="language-plaintext highlighter-rouge">IdleHandler</code>’ов. Для этого в методе <code class="language-plaintext highlighter-rouge">next</code>, после того как станет понятно, что доступных для выполнения сообщений в основной очереди нет, выполнится следующий код:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nc">Message</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
   <span class="kt">int</span> <span class="n">pendingIdleHandlerCount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
   <span class="o">..................</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">pendingIdleHandlerCount</span> <span class="o">&lt;</span> <span class="mi">0</span>
          <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">mMessages</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">mMessages</span><span class="o">.</span><span class="na">when</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">pendingIdleHandlerCount</span> <span class="o">=</span> <span class="n">mIdleHandlers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
   <span class="o">}</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">pendingIdleHandlerCount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">mBlocked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="k">continue</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="o">..................</span>

<span class="o">}</span>
</pre></table></code></div></div><p>По сути произойдёт проверка, что в ходе выполнения метода <code class="language-plaintext highlighter-rouge">next</code>, <code class="language-plaintext highlighter-rouge">IdleHandler</code>’ы ещё не запускались, а также что сообщений в очереди, которые нужно обработать прямо сейчас, уже нет. Если это так, то начнётся обработка <code class="language-plaintext highlighter-rouge">IdleHandler</code>, иначе просто будет обработано следующее сообщение.</p><p>Настало время выполнить <code class="language-plaintext highlighter-rouge">IdleHandler</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="nc">IdleHandler</span><span class="o">[]</span> <span class="n">mPendingIdleHandlers</span><span class="o">;</span>

<span class="nc">Message</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
   <span class="o">..................</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">mPendingIdleHandlers</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">mPendingIdleHandlers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IdleHandler</span><span class="o">[</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">pendingIdleHandlerCount</span><span class="o">,</span> <span class="mi">4</span><span class="o">)];</span>
<span class="o">}</span>
   <span class="n">mPendingIdleHandlers</span> <span class="o">=</span> <span class="n">mIdleHandlers</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">mPendingIdleHandlers</span><span class="o">);</span>
   <span class="o">..................</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Для этого значения из <code class="language-plaintext highlighter-rouge">mIdleHandlers</code> копируются в отдельный массив <code class="language-plaintext highlighter-rouge">mPendingIdleHandlers</code>. Отдельный массив нужен, чтобы избежать проблем с многопоточностью.</p><p>Само же выполнение происходит достаточно стандартно. В цикле мы проходим по нашим <code class="language-plaintext highlighter-rouge">IdleHandler</code> и последовательно выполняем каждый из них.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="nc">IdleHandler</span><span class="o">[]</span> <span class="n">mPendingIdleHandlers</span><span class="o">;</span>

<span class="nc">Message</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
   <span class="o">..................</span>
   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pendingIdleHandlerCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="nc">IdleHandler</span> <span class="n">idler</span> <span class="o">=</span> <span class="n">mPendingIdleHandlers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
      <span class="n">mPendingIdleHandlers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

      <span class="kt">boolean</span> <span class="n">keep</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
      <span class="k">try</span> <span class="o">{</span>
          <span class="n">keep</span> <span class="o">=</span> <span class="n">idler</span><span class="o">.</span><span class="na">queueIdle</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
          <span class="nc">Log</span><span class="o">.</span><span class="na">wtf</span><span class="o">(</span><span class="no">TAG</span><span class="o">,</span> <span class="s">"IdleHandler threw exception"</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="k">if</span> <span class="o">(!</span><span class="n">keep</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">mIdleHandlers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">idler</span><span class="o">);</span>
          <span class="o">}</span>
      <span class="o">}</span>
   <span class="o">}</span>
   <span class="n">pendingIdleHandlerCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>При этом выполнение обёрнуто в <code class="language-plaintext highlighter-rouge">try-catch</code>. После выполнения, в зависимости от результата метода <code class="language-plaintext highlighter-rouge">queueIdle</code>, <code class="language-plaintext highlighter-rouge">IdleHandler</code> удалится из общего списка на выполнение. Если во время выполнения <code class="language-plaintext highlighter-rouge">IdleHandler</code> бросит исключение, то он так же удалится из списка на выполнение.</p><p>От чего-то полезного перейдём к тому, чем вы по идее никогда не должны пользоваться, ну разве что очень редко.</p><h4 id="syncbarrier">syncBarrier</h4><p><code class="language-plaintext highlighter-rouge">syncBarrier</code> нужен для того, чтобы остановить выполнение очереди сообщений по какой-либо причине.</p><p>К сожалению (или к счастью) методы работы с <code class="language-plaintext highlighter-rouge">syncBarrier</code> помечены аннотацией <code class="language-plaintext highlighter-rouge">Hide</code>, а значит мы не сможем вызвать их из своего кода честными методами.</p><p>Основной способ использования этого механизма появился в Android 5. В нём появился выделенный поток для рендеринга (до этого рендеринг происходил на главном потоке). Из-за этого пришлось придумывать как останавливать обработку главного потока, а конкретно его задач, связанных с интерфейсом, пока поток рендеринга считывал дерево <code class="language-plaintext highlighter-rouge">View</code>.</p><p>Работает этот механизм очень просто. Для того чтобы исполнение очереди сообщений приостановилось, в очередь сообщений добавляется особо промаркированное сообщение.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/queue-marked-message.png" alt="queue-marked-message" /></p><p>Далее, когда при выполнении метода <code class="language-plaintext highlighter-rouge">MessageQueue</code> <code class="language-plaintext highlighter-rouge">next</code> оно окажется следующим, то очередь сообщений остановится вместо того чтобы выполнять сообщения.</p><p>Затем, когда нужно восстановить обработку очереди сообщений, промаркированное сообщение удаляется и очередь продолжает работать как ни в чём не бывало.</p><p>Но ведь не всё задачи главного потока связаны с отрисовкой <code class="language-plaintext highlighter-rouge">View</code>. Зачем останавливать все сообщения? Разработчики Android SDK подумали так же. Вы можете пометить ваше сообщение как асинхронное, с помощью метода <code class="language-plaintext highlighter-rouge">Message.setAsynchronous(true)</code>. На такие сообщения <code class="language-plaintext highlighter-rouge">syncBarrier</code> не распространяется и они продолжат выполняться в обычном режиме.</p><h3 id="message-1">Message</h3><p><em>Важное примечание. Класс <code class="language-plaintext highlighter-rouge">Message</code> и <code class="language-plaintext highlighter-rouge">Handler</code> мы будем рассматривать только в контексте главного цикла. Другие их особенности, связанные с возможностью передачи сообщений между потоками и между разными узлами приложения - сейчас опустим.</em></p><h4 id="pool-obtain-recycle">Pool, obtain, recycle</h4><p>У <code class="language-plaintext highlighter-rouge">Message</code> имеется <code class="language-plaintext highlighter-rouge">private</code> конструктор. Для чего это сделано? Так как, за время работы процесса в нём генерируется и пересылается огромное количество сообщений, то каждый раз создавать новый объект <code class="language-plaintext highlighter-rouge">Message</code> будет весьма затратно. Даже такая простая вещь как создание объекта при большом количестве вызовов может иметь значение. Поэтому используется особый <code class="language-plaintext highlighter-rouge">pool</code> сообщений. В него будут складываться уже ставшие ненужными объекты <code class="language-plaintext highlighter-rouge">Message</code> и, когда нам понадобится новое сообщение, мы вместо создания нового объекта просто будем переиспользовать старый ненужный объект.</p><p>Так же, как и в случае с очередью сообщений, <code class="language-plaintext highlighter-rouge">pool</code> представляет из себя односвязный список, ссылка на начало которого хранится в поле <code class="language-plaintext highlighter-rouge">sPool</code>. Отдельным полем <code class="language-plaintext highlighter-rouge">sPoolSize</code> хранится размер этого списка, он нам понадобится, чтобы наш <code class="language-plaintext highlighter-rouge">pool</code> не слишком разрастался и мы могли контролировать его размер.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="nc">Message</span> <span class="n">sPool</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">sPoolSize</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">sPoolSync</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
</pre></table></code></div></div><p>Так как конструктор приватный, то новое сообщение создаётся через метод <code class="language-plaintext highlighter-rouge">obtain</code>. Рассмотрим его подробнее:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">Message</span> <span class="nf">obtain</span><span class="o">()</span> <span class="o">{</span>
   <span class="kd">synchronized</span> <span class="o">(</span><span class="n">sPoolSync</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">sPool</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
           <span class="nc">Message</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sPool</span><span class="o">;</span>
           <span class="n">sPool</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
           <span class="n">m</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
           <span class="n">m</span><span class="o">.</span><span class="na">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
           <span class="n">sPoolSize</span><span class="o">--;</span>
           <span class="k">return</span> <span class="n">m</span><span class="o">;</span>
       <span class="o">}</span>
   <span class="o">}</span>
   <span class="k">return</span> <span class="k">new</span> <span class="nf">Message</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Первое что нас ждёт - блок синхронизации, внутри него мы смотрим - есть ли у нас сообщения в <code class="language-plaintext highlighter-rouge">sPool</code>. Если есть, то забираем первое сообщение из <code class="language-plaintext highlighter-rouge">pool</code> и возвращаем его, при этом не забывая поменять ссылку на начало списка и уменьшить значение <code class="language-plaintext highlighter-rouge">sPoolSize</code>.</p><p>Если же в <code class="language-plaintext highlighter-rouge">sPool</code> сообщений нет, то создаём новое сообщение через приватный конструктор. Но как объекты попадают в <code class="language-plaintext highlighter-rouge">sPool</code>? Для этого, после того как <code class="language-plaintext highlighter-rouge">MessageQueue</code> выполняет действие сообщения, оно вызывает у него метод <code class="language-plaintext highlighter-rouge">recycle</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">recycle</span><span class="o">()</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">isInUse</span><span class="o">())</span> <span class="o">{</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">gCheckRecycle</span><span class="o">)</span> <span class="o">{</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"This message cannot be recycled because it "</span>
                   <span class="o">+</span> <span class="s">"is still in use."</span><span class="o">);</span>
       <span class="o">}</span>
       <span class="k">return</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="n">recycleUnchecked</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Внутри этого метода сначала проверяется - используется ли сейчас сообщение, если да, то бросается исключение, ведь в <code class="language-plaintext highlighter-rouge">sPool</code> должны попадать уже ненужные сообщения. Иначе вызывается приватный метод <code class="language-plaintext highlighter-rouge">recycleUnchecked</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">recycleUnchecked</span><span class="o">()</span> <span class="o">{</span>
   <span class="n">flags</span> <span class="o">=</span> <span class="no">FLAG_IN_USE</span><span class="o">;</span>
   <span class="n">what</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
   <span class="n">arg1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
   <span class="n">arg2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
   <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   <span class="n">replyTo</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   <span class="n">sendingUid</span> <span class="o">=</span> <span class="no">UID_NONE</span><span class="o">;</span>
   <span class="n">workSourceUid</span> <span class="o">=</span> <span class="no">UID_NONE</span><span class="o">;</span>
   <span class="n">when</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
   <span class="n">target</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   <span class="n">callback</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   <span class="n">data</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

   <span class="kd">synchronized</span> <span class="o">(</span><span class="n">sPoolSync</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">sPoolSize</span> <span class="o">&lt;</span> <span class="no">MAX_POOL_SIZE</span><span class="o">)</span> <span class="o">{</span>
           <span class="n">next</span> <span class="o">=</span> <span class="n">sPool</span><span class="o">;</span>
           <span class="n">sPool</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
           <span class="n">sPoolSize</span><span class="o">++;</span>
       <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Внутри <code class="language-plaintext highlighter-rouge">recycleUnchecked</code> во все поля сообщения выставляются значения по умолчанию, а затем если наш <code class="language-plaintext highlighter-rouge">pool</code> ещё не заполнен, то в него добавляется наше сообщение, при этом значение <code class="language-plaintext highlighter-rouge">sPoolSize</code> увеличивается.</p><h3 id="handler">Handler</h3><h4 id="зачем-он-нужен">Зачем он нужен</h4><p>Помимо <code class="language-plaintext highlighter-rouge">Looper</code>, <code class="language-plaintext highlighter-rouge">Message</code> и <code class="language-plaintext highlighter-rouge">MessageQueue</code> в главном цикле Android SDK присутствует ещё один класс - <code class="language-plaintext highlighter-rouge">Handler</code>. Для чего же он нужен? Дело в том, что что с точки зрения безопасности и стабильности кода давать программистам прямой доступ к очереди сообщений может быть опасно. Помимо того, что кто-то может напакостить, поменяв очередь, так ещё и такие изменения будет очень сложно отследить. Для решения этой проблемы и нужен <code class="language-plaintext highlighter-rouge">Handler</code>, он является фасадом для логики работы с очередью сообщений.</p><p>Если мы захотим из кода приложения добавить новое сообщение в очередь, то мы должны делать это через <code class="language-plaintext highlighter-rouge">Handler</code>, напрямую это сделать никак не получится, так как большинство методов <code class="language-plaintext highlighter-rouge">MessageQueue</code> имеют видимость <code class="language-plaintext highlighter-rouge">package-local</code>, а не <code class="language-plaintext highlighter-rouge">public</code>.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/android-handler.png" alt="android-handler" /></p><h4 id="post-и-postdelayed">post и postDelayed</h4><p>Итак, мы захотели добавить новое сообщение в очередь. Как нам это сделать? Для добавления нового сообщения в очередь у <code class="language-plaintext highlighter-rouge">Handler</code> есть методы <code class="language-plaintext highlighter-rouge">post</code> и <code class="language-plaintext highlighter-rouge">postDelayed</code>. Эти методы есть не только у <code class="language-plaintext highlighter-rouge">Handler</code>, но и например у <code class="language-plaintext highlighter-rouge">view</code>: <code class="language-plaintext highlighter-rouge">post</code>, <code class="language-plaintext highlighter-rouge">postDelayed</code>, есть аналог и у <code class="language-plaintext highlighter-rouge">Activity</code>: <code class="language-plaintext highlighter-rouge">runOnUiThread</code>, но все они так или иначе в итоге сводятся к вызову <code class="language-plaintext highlighter-rouge">Handler</code>.</p><p>Метод <code class="language-plaintext highlighter-rouge">post</code> просто добавляет новое сообщение в конец очереди.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/android-post.png" alt="android-post-delayed" /></p><p>Метод <code class="language-plaintext highlighter-rouge">postDelayed</code> добавляет отложенное сообщение, которое выполнится через определенный промежуток времени. Для этого в поле <code class="language-plaintext highlighter-rouge">when</code> класса <code class="language-plaintext highlighter-rouge">Message</code> записывается время с момента старта JVM + время через которое надо выполнить сообщение, таким образом <code class="language-plaintext highlighter-rouge">MessageQueue</code> понимает когда надо выполнить сообщение.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/android-post-delayed.png" alt="android-post-delayed" /></p><p>Стоит заметить, что с <code class="language-plaintext highlighter-rouge">postDelayed</code> стоит быть аккуратными если вы используете их в объектах с коротким жизненным циклом. Иначе может сложиться ситуация, когда ваш объект уже готов быть собран сборщиком мусора, но сообщение, которое он отправил, ещё не успело выполниться. В случае с <code class="language-plaintext highlighter-rouge">post</code> беда не велика и я бы даже назвал это микроутечкой памяти, но в случае с <code class="language-plaintext highlighter-rouge">postDelayed</code> это уже может быть скорее миниутечка, ведь объект утечёт на тот период времени, что вы указали.</p><p>На мой взгляд, это пожалуй всё самое интересное из Android SDK, связанное с <code class="language-plaintext highlighter-rouge">Looper</code>, <code class="language-plaintext highlighter-rouge">MessageQueue</code> и <code class="language-plaintext highlighter-rouge">Message</code>. Поэтому можно сказать, что как главный цикл работает в Android SDK и какие особенности имеет мы разобрались. По крайней мере на слое Java, но есть же ещё и упомянутый C++ слой. Да и не секрет, что Android приложения пишутся не только с помощью Java Android SDK, есть Flutter, React Native, Chrome и игры.</p><hr /><h2 id="другие-главные-циклы">Другие главные циклы</h2><p>В этой части мы посмотрим на особенности <code class="language-plaintext highlighter-rouge">Looper</code> в C++, поверхностно пробежимся по Flutter, Chrome и React Native. А ещё есть игры — в них вообще всё с ног на голову.</p><p>Тут мы начинаем заходить на окраину территории моих знаний, поэтому если где-то будут неточности, то обязательно поправляйте меня в комментариях. Также из-за этого в статье будет много ссылок, чтобы было что почитать на досуге.</p><h3 id="looper-в-c-слое">Looper в C++ слое</h3><h4 id="общая-логика">Общая логика</h4><p>В предыдущей части я упомянул, что <code class="language-plaintext highlighter-rouge">Looper</code> из Java вызывает <code class="language-plaintext highlighter-rouge">Looper</code> из C++. Как можно догадаться, в слое C++ есть свой <code class="language-plaintext highlighter-rouge">Looper</code>, который отвечает за сам цикл и его работу, своя очередь сообщений и свой <code class="language-plaintext highlighter-rouge">Message</code>. Далее в рассуждениях я буду отталкиваться от того, что вы прочли предыдущие части статьи и/или понимаете общую логику работы главного цикла и его особенности в Java слое Android SDK.</p><p>В итоге у нас есть два <code class="language-plaintext highlighter-rouge">Looper</code>, а значит, нужно как-то передавать управление C++ слою. Для этого в Java слое вызывается метод <code class="language-plaintext highlighter-rouge">nativePollOnce</code>. Каждый раз когда в <code class="language-plaintext highlighter-rouge">MessageQueue</code> мы пытаемся найти следующее сообщение, сначала вызывается <code class="language-plaintext highlighter-rouge">nativePollOnce</code>. В этот момент наступает очередь <code class="language-plaintext highlighter-rouge">Looper</code> из C++ обрабатывать сообщения, и он вернёт управление в Java слой лишь тогда, когда он закончит обрабатывать все свои текущие сообщения. Важно понимать, что оба этих <code class="language-plaintext highlighter-rouge">Looper</code> работают в одном потоке — <code class="language-plaintext highlighter-rouge">MainThread</code>, то есть у нас имеется две очереди основных событий на один поток. Следовательно, если «заспамить» очередь из C++, то очередь из Java вообще не будет продвигаться. Получается следующая схема:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/main-loop-scheme-with-c++.png" alt="main-loop-scheme-with-c++" /></p><p>Интересно, что с точки зрения кода <code class="language-plaintext highlighter-rouge">Looper</code> из C++ сочетает в себе и логику <code class="language-plaintext highlighter-rouge">Looper</code> и логику <code class="language-plaintext highlighter-rouge">MessageQueue</code>. Да и в целом написан не так аккуратно, как его собрат из Java слоя. При желании можете удостовериться в этом сами, посмотрев его <a href="https://android.googlesource.com/platform/system/core/+/master/libutils/Looper.cpp" title="android.googlesource.com">исходный код</a> с заголовочным <a href="https://android.googlesource.com/platform/system/core/+/master/libutils/include/utils/Looper.h" title="android.googlesource.com">файлом</a>. По этой причине, код я прикладывать особо не буду, но всё же рассмотрим избранные куски.</p><p>Для начала начнём с самого сообщения — класса <code class="language-plaintext highlighter-rouge">Message</code>. Оно здесь сделано настолько просто, насколько это вообще было возможно. По сути у нас есть только одна переменная <code class="language-plaintext highlighter-rouge">what</code> и два конструктора.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Message</span> <span class="p">{</span>
    <span class="n">Message</span><span class="p">()</span> <span class="o">:</span> <span class="n">what</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">Message</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">)</span> <span class="o">:</span> <span class="n">what</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">what</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>А как же тогда указать в сообщении, что оно должно делать? Для этого в переменную <code class="language-plaintext highlighter-rouge">what</code> надо записать идентификатор действия, которое мы хотим выполнить. Затем обработчик считает этот идентификатор и выполнит соответствующее действие. В качестве обработчика выступают наследники <code class="language-plaintext highlighter-rouge">MessageHandler</code>.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MessageHandler</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">RefBase</span> <span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">MessageHandler</span><span class="p">();</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handleMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>У <code class="language-plaintext highlighter-rouge">MessageHandler</code> есть всего один виртуальный (считай абстрактный) метод, который мы и должны переопределить. Внутри него мы можем считать идентификатор и выполнить действие, которое к нему предписано. В целом если делать по отдельному <code class="language-plaintext highlighter-rouge">MessageHandler</code> на каждый <code class="language-plaintext highlighter-rouge">Message</code>, то всеми премудростями с идентификатором можно и не заниматься. Есть сообщение и есть его обработчик, который всегда выполняет одно и тоже действие.</p><p>Но как нам теперь связать сообщение с его обработчиком? Для этого существует <code class="language-plaintext highlighter-rouge">MessageEnvelope</code>. В нём и находятся:</p><ul><li>экземпляр <code class="language-plaintext highlighter-rouge">Message</code> с которым познакомились выше;<li><a href="https://android.googlesource.com/platform/frameworks/native/+/android-4.2.2_r1/include/utils/StrongPointer.h" title="android.googlesource.com">StrongPointer</a> на <code class="language-plaintext highlighter-rouge">MessageHandler</code>, являющийся <a href="https://ru.wikipedia.org/wiki/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)" title="ru.wikipedia.org">указателем</a> с встроенным счетчиком ссылок, чтобы мы могли, без лишних проблем, переиспользовать один экземпляр <code class="language-plaintext highlighter-rouge">MessageHandler</code> для нескольких сообщений;<li><code class="language-plaintext highlighter-rouge">uptime</code> для хранения времени со старта процесса. Она несёт в себе такой же смысл как и <code class="language-plaintext highlighter-rouge">when</code> в <code class="language-plaintext highlighter-rouge">Message</code> из Java, то есть это время в которое надо выполнить сообщение. Очень полезно для отложенных операций.</ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">MessageEnvelope</span> <span class="p">{</span>
    <span class="n">MessageEnvelope</span><span class="p">()</span> <span class="o">:</span> <span class="n">uptime</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">MessageEnvelope</span><span class="p">(</span><span class="n">nsecs_t</span> <span class="n">u</span><span class="p">,</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">MessageHandler</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">uptime</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">handler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">h</span><span class="p">)),</span> <span class="n">message</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">nsecs_t</span> <span class="n">uptime</span><span class="p">;</span>
    <span class="n">sp</span><span class="o">&lt;</span><span class="n">MessageHandler</span><span class="o">&gt;</span> <span class="n">handler</span><span class="p">;</span>
    <span class="n">Message</span> <span class="n">message</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>По сути, создав объект <code class="language-plaintext highlighter-rouge">MessageEnvelope</code>, мы свяжем наше сообщение с его обработчиком. Такой объект уже можно, без зазрения совести, класть в очередь сообщений. Кстати о ней.</p><p>Она представлена обычным классом <code class="language-plaintext highlighter-rouge">Vector</code>, который по сути является улучшенным одномерным массивом. Как я упоминал выше - хранится эта очередь в самом <code class="language-plaintext highlighter-rouge">Looper</code> в переменной <code class="language-plaintext highlighter-rouge">mMessageEnvelopes</code>.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">Vector</span><span class="o">&lt;</span><span class="n">MessageEnvelope</span><span class="o">&gt;</span> <span class="n">mMessageEnvelopes</span><span class="p">;</span>
</pre></table></code></div></div><p>В основной логике <code class="language-plaintext highlighter-rouge">Looper</code> из C++ похож на своего собрата из Java слоя, но у него есть один нюанс, который мы ещё не рассмотрели. Если <code class="language-plaintext highlighter-rouge">Looper</code> из Java вместо ожидания передает управление в Looper из C++, то что же делает последний, когда сообщения в очереди закончились и надо действительно ждать? Передавать управление более нижнему слою уже нельзя, мы на самом дне. Надо действительно ждать.</p><h4 id="ожидание">Ожидание</h4><p>Для начала давайте посмотрим чуть подробнее на <code class="language-plaintext highlighter-rouge">wait</code> и <code class="language-plaintext highlighter-rouge">notify</code> из Java. Каждый объект в Java имеет свой <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B8%D1%82%D0%BE%D1%80_(%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F)" title="ru.wikipedia.org">монитор</a>. При вызове <code class="language-plaintext highlighter-rouge">wait</code> у монитора произойдет перемещение текущего потока в <code class="language-plaintext highlighter-rouge">wait set</code> монитора. Пока поток находится в <code class="language-plaintext highlighter-rouge">wait set</code> он «спит». При вызове <code class="language-plaintext highlighter-rouge">notify</code> или <code class="language-plaintext highlighter-rouge">notifyAll</code> пробуждается один или все потоки, которые сейчас находятся в <code class="language-plaintext highlighter-rouge">wait set</code> монитора.</p><p>В С++ похожее поведение реализуют <a href="https://en.cppreference.com/w/cpp/thread/condition_variable" title="en.cppreference.com">condition_variable</a>, но в <code class="language-plaintext highlighter-rouge">Looper</code> используется другой подход - связка <code class="language-plaintext highlighter-rouge">epoll</code> + <code class="language-plaintext highlighter-rouge">eventfd</code>. В отличии от <code class="language-plaintext highlighter-rouge">wait-notify/condition_variable</code>, которые предоставляют синхронизацию только внутри процесса, <a href="https://man7.org/linux/man-pages/man7/epoll.7.html" title="man7.org">epoll</a> + <a href="https://man7.org/linux/man-pages/man2/eventfd.2.html" title="man7.org">eventfd</a> предоставляет синхронизацию как внутри процесса, так и между процессами. Взглянем на этот подход подробнее. Начнем с <code class="language-plaintext highlighter-rouge">eventfd</code>.</p><h4 id="eventfd">eventfd</h4><p>Прежде чем разбираться с <code class="language-plaintext highlighter-rouge">eventfd</code>, нужно сначала разобраться с тем, что такое файловый дескриптор, так как логика <code class="language-plaintext highlighter-rouge">eventfd</code> основана на нём.</p><p>Мне наиболее простым и понятным кажется определение файлового дескриптора как - уникальный идентификатор для ресурса ввода-вывода. Им может быть файл, каталог, сокет, stdin, stdout и т.д. Сам файловый дескриптор управляется на уровне операционной системы. Когда вы хотите открыть файл или сокет, или что-то еще, это делает ядро. Оно знает много чего ещё про открытый файл, но отдаёт только этот идентификатор (который, кстати, уникален только в рамках одного процесса). Так же нельзя открыть файл с дескрипторами 0, 1 и 2 — при создании процесса ядро автоматически открывает их для ввода, вывода и сообщений об ошибках. Подробнее можно почитать <a href="https://timeweb.com/ru/community/articles/chto-takoe-faylovyy-deskriptor-prostymi-slovami" title="timeweb.com">тут</a>.</p><p><code class="language-plaintext highlighter-rouge">eventfd</code> - это <strong>kernel system call</strong>, при вызове возвращающий нам файловый дескриптор, который будет использоваться для уведомления о новых событиях. Может использоваться как внутри приложения, так и для уведомления приложения ядром системы.</p><p>Для начала получим наш файловый дескриптор <code class="language-plaintext highlighter-rouge">eventfd</code> и поместим его в хранилище в переменной <code class="language-plaintext highlighter-rouge">mWakeEventFd</code>:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">mWakeEventFd</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">eventfd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EFD_NONBLOCK</span> <span class="o">|</span> <span class="n">EFD_CLOEXEC</span><span class="p">));</span>
</pre></table></code></div></div><p>Если проводить аналогию с привычным нам подходом <code class="language-plaintext highlighter-rouge">wait</code>/<code class="language-plaintext highlighter-rouge">notify</code> с монитором, то файловый дескриптор, который нам отдаст <code class="language-plaintext highlighter-rouge">eventfd</code>, будет аналогом монитора.</p><p>Теперь нужны аналоги для <code class="language-plaintext highlighter-rouge">wait</code> и <code class="language-plaintext highlighter-rouge">notify</code>. Начнем с <code class="language-plaintext highlighter-rouge">wait</code>, в качестве него выступит <code class="language-plaintext highlighter-rouge">epoll</code>.</p><h4 id="epoll">(e)poll</h4><p><code class="language-plaintext highlighter-rouge">poll</code> - это <strong>kernel system call</strong>, который позволяет отслеживать файловый дескриптор. <code class="language-plaintext highlighter-rouge">epoll</code> - это улучшенная версия <code class="language-plaintext highlighter-rouge">poll</code>, которая работает <a href="http://www.xmailserver.org/linux-patches/nio-improve.html" title="xmailserver.org">оптимальнее</a>. Что важно, при создании экземпляра <code class="language-plaintext highlighter-rouge">epoll</code> нам возвращается файловый дескриптор, указывающий на него, так что в теории мы можем с помощью <code class="language-plaintext highlighter-rouge">epoll</code> отслеживать другой экземпляр <code class="language-plaintext highlighter-rouge">epoll</code>.</p><p>Из этой утилиты нам понадобятся следующий методы - <code class="language-plaintext highlighter-rouge">epoll_wait</code>, <code class="language-plaintext highlighter-rouge">epoll_ctl</code> и <code class="language-plaintext highlighter-rouge">epoll_create1</code>.</p><p>Для начала создадим экземпляр <code class="language-plaintext highlighter-rouge">epoll</code>, а связанный с ним файловый дескриптор запишем в хранилище в переменной <code class="language-plaintext highlighter-rouge">mEpollFd</code>.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">mEpollFd</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">epoll_create1</span><span class="p">(</span><span class="n">EPOLL_CLOEXEC</span><span class="p">));</span>
</pre></table></code></div></div><p>Затем с помощью <code class="language-plaintext highlighter-rouge">epoll_ctl</code> мы указываем, что <code class="language-plaintext highlighter-rouge">epoll</code> должен отслеживать дескриптор, полученный от <code class="language-plaintext highlighter-rouge">eventfd</code>.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">mEpollFd</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">mWakeEventFd</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">wakeEvent</span><span class="p">);</span>
</pre></table></code></div></div><p>Ну и в конце концов в том месте, где мы будем ждать новых событий, вызовем метод <code class="language-plaintext highlighter-rouge">epoll_wait</code>. Он будет ждать появления новых данных об объектах за которыми, с помощью файловых дескрипторов, следит <code class="language-plaintext highlighter-rouge">epoll</code>. В итоге он вернёт нам количество событий, произошедших с объектами с момента последнего отслеживания.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">eventCount</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span>
    <span class="n">mEpollFd</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>
    <span class="n">eventItems</span><span class="p">,</span>
    <span class="n">EPOLL_MAX_EVENTS</span><span class="p">,</span>
    <span class="n">timeoutMillis</span><span class="p">);</span>
</pre></table></code></div></div><p>При вызове <code class="language-plaintext highlighter-rouge">epoll_wait</code> мы либо сразу получим количество событий с последнего отслеживания, либо, если событий нет, будем их дожидаться. Механизм <code class="language-plaintext highlighter-rouge">epoll</code> также поддерживает ожидание по времени - для этого достаточно передать в метод нужное нам время. В нашем случае это делается с помощью переменной <code class="language-plaintext highlighter-rouge">timeoutMillis</code>. Это позволяет потоку ждать, пока не поступят новые данные, или не истечет заданное в <code class="language-plaintext highlighter-rouge">timeoutMillis</code> время, в зависимости от того, что произойдет раньше. Это нужно для поддержки отложенных сообщений.</p><p>То, как <code class="language-plaintext highlighter-rouge">Looper</code> начинает ждать мы разобрались. Теперь пора бы перейти к последнему - пробуждению. Тут к счастью всё достаточно просто. Для этого используется <code class="language-plaintext highlighter-rouge">write</code>.</p><h4 id="write">write</h4><p><a href="https://man7.org/linux/man-pages/man2/write.2.html" title="man7.org">write</a> - простой метод, который записывает байты в ресурс, связанный с файловым дескриптором. В нашем случае в качестве байтов выступит просто единица формата <code class="language-plaintext highlighter-rouge">uint64_t</code>. Нам ведь просто надо уведомить <code class="language-plaintext highlighter-rouge">epoll</code>, а не передать какие-либо данные.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">uint64_t</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">write</span><span class="p">(</span><span class="n">mWakeEventFd</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">inc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">))</span>
</pre></table></code></div></div><p>По итогу логика получается следующей:</p><ul><li>создаём объект <code class="language-plaintext highlighter-rouge">eventfd</code> и получаем файловый дескриптор указывающий на него;<li>создаём экземпляр <code class="language-plaintext highlighter-rouge">epoll</code>;<li>указываем экземпляру <code class="language-plaintext highlighter-rouge">epoll</code> следить за файловым дескриптором, полученным от <code class="language-plaintext highlighter-rouge">eventfd</code>;<li>когда задачи заканчиваются, с помощью <code class="language-plaintext highlighter-rouge">epoll</code> начинаем ждать, вызвав <code class="language-plaintext highlighter-rouge">epoll_wait</code>;<li>при появлении нового сообщения пишем в ресурс, привязанный к файловому дескриптору <code class="language-plaintext highlighter-rouge">eventfd</code>, тем самым уведомляя <code class="language-plaintext highlighter-rouge">epoll</code>.</ul><p>Логика не сложная, но достаточно тяжело воспринимаемая из-за непривычных для Android разработчика файловых дескрипторов.</p><p>Общий путь ожиданий и пробуждений, включая Java слой, получается довольно длинным:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/main-loop-scheme-epoll-eventfd.png" alt="main-loop-scheme-epoll-eventfd" /></p><p>С Android SDK покончено, давайте перейдём к поверхностному рассмотрению альтернативных фреймворков для разработки под Android. Рассмотрим конечно же не всё. Только то, что является достаточно популярным или обладает своими особенностями.</p><h3 id="flutter">Flutter</h3><p>Начнём мы с Flutter. Штука эта мультиплатформенная, так что в зависимости от платформы конечная реализация может быть немного разной. Поэтому рассмотрим всё достаточно абстрактно.</p><h4 id="две-очереди">Две очереди</h4><p>Основной особенностью главного цикла во Flutter является наличие двух очередей: очередь <code class="language-plaintext highlighter-rouge">Event</code> и очередь <code class="language-plaintext highlighter-rouge">MicroTask</code>.</p><p>Первая очередь нам уже привычна и понятна - это очередь основных событий, а вот вторая очередь уже интереснее. Она используется для очень коротких событий, которые желательно выполнить как можно скорее.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/flutter-first-queue.png" alt="flutter-first-queue" /></p><p>С точки зрения кода это выглядит примерно так:</p><div class="language-dart highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">loop</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
 <span class="kd">var</span> <span class="n">isAlive</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
 <span class="k">while</span> <span class="o">(</span><span class="n">isAlive</span><span class="o">)</span> <span class="o">{</span>
   <span class="o">........................................</span>
   <span class="k">while</span> <span class="o">(</span><span class="n">_microTaskQueue</span><span class="o">.</span><span class="na">isNotEmpty</span><span class="o">)</span> <span class="o">{</span>
     <span class="kd">final</span> <span class="n">currentMicroTask</span> <span class="o">=</span> <span class="n">_microTaskQueue</span><span class="o">.</span><span class="na">first</span><span class="o">;</span>
     <span class="n">currentMicroTask</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
     <span class="n">_microTaskQueue</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">currentMicroTask</span><span class="o">);</span>
   <span class="o">}</span>

   <span class="k">if</span> <span class="o">(</span><span class="n">_eventQueue</span><span class="o">.</span><span class="na">isNotEmpty</span><span class="o">)</span> <span class="o">{</span>
     <span class="kd">final</span> <span class="n">currentEvent</span> <span class="o">=</span> <span class="n">_eventQueue</span><span class="o">.</span><span class="na">first</span><span class="o">;</span>
     <span class="n">currentEvent</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
     <span class="n">_eventQueue</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">currentEvent</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="o">........................................</span>
 <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>В каждом проходе цикла мы проверяем, есть ли у нас сообщение в очереди событий <code class="language-plaintext highlighter-rouge">MicroTask</code>, если там есть сообщение, то оно выполняется и удаляется из очереди. Если нет - то тоже самое происходит с очередью <code class="language-plaintext highlighter-rouge">Event</code>. По сути очередь <code class="language-plaintext highlighter-rouge">MicroTask</code> - это та же очередь, просто имеющая наивысший приоритет, и пока эта очередь не опустеет, события из очереди <code class="language-plaintext highlighter-rouge">Event</code> не будут выполняться.</p><h4 id="isolate">Isolate</h4><p>Также во Flutter нет привычной системы потоков, но есть <code class="language-plaintext highlighter-rouge">Isolate</code>. Он похож на обычные потоки в других языках, но при этом <code class="language-plaintext highlighter-rouge">Isolate</code> не делят память между собой, то есть нельзя по привычной для нас схеме менять одну переменную из двух разных <code class="language-plaintext highlighter-rouge">Isolate</code>, а значит и проблем с синхронизацией по большей части нет. Интересующей же нас особенностью является то, что каждый из <code class="language-plaintext highlighter-rouge">Isolate</code> имеет свой цикл событий с собственными очередями <code class="language-plaintext highlighter-rouge">Event</code> и <code class="language-plaintext highlighter-rouge">MicroTask</code>. Общаются же <code class="language-plaintext highlighter-rouge">Isolate</code> c помощью сообщений, которые они могут посылать друг другу. Таким образом вообще все действия во Flutter выполняются в циклах событий.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/flutter-two-queue.png" alt="flutter-two-queue" /></p><p>Подробнее про это можно прочитать в этой <a href="https://www.didierboelens.com/2019/01/futures-isolates-event-loop/" title="didierboelens.com">статье</a> (<a href="https://habr.com/ru/post/497278/" title="habr.com">перевод</a>).</p><h3 id="chrome">Chrome</h3><p>Многие фреймворки для кроссплатформенной разработки, например <a href="https://cordova.apache.org/" title="cordova.apache.org">Cordova</a>, используют системный <code class="language-plaintext highlighter-rouge">WebView</code>, также не стоит забывать про <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%B2%D0%B5%D0%B1-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5" title="ru.wikipedia.org">PWA</a> (хотя, кажется, все уже забыли). Начиная с Android 7, при использовании стандартного <code class="language-plaintext highlighter-rouge">WebView</code> <a href="https://developer.android.com/about/versions/nougat/android-7.0#webview" title="developer.android.com">под капотом используется Chrome</a>. Следовательно, довольно много Android приложений используют Chrome. Так что стоит присмотреться и к его главному циклу.</p><p><a href="https://chromium.googlesource.com/chromium/chromium/+/refs/heads/main/third_party/libevent" title="chromium.googlesource.com">Он основан</a> на open-source библиотеке <a href="https://libevent.org/" title="libevent.org">libevent</a>. Эта кроссплатформенная библиотека, специально созданная для реализации циклов событий как UI, так и серверных приложений. Она сразу предоставляет все самые необходимые вещи как: отложенные сообщения, множественные очереди, приоритеты и прочие вещи которые могут понадобиться при работе с циклами событий.</p><p>(Кстати, в Android SDK эта библиотека тоже <a href="https://android.googlesource.com/platform/external/libevent/" title="android.googlesource.com">есть</a>, но по какой-то причине для главного цикла не используется, правда и добавили её туда только в 2015 году.)</p><p>В зависимости от платформы <code class="language-plaintext highlighter-rouge">libevent</code> использует разные способы ожидания/пробуждения. Конкретно в Android используется старый добрый <code class="language-plaintext highlighter-rouge">epoll</code> + <code class="language-plaintext highlighter-rouge">eventfd</code>. В других платформах реализация может отличаться.</p><p>Поверх этой библиотеки написана обёртка. В целом логика похожа на цикл Flutter (что не удивительно, учитывая “корни” языка Dart) - отдельная очередь <code class="language-plaintext highlighter-rouge">Task</code> и отдельная очередь <code class="language-plaintext highlighter-rouge">Microtask</code>. Но есть особенность, которая сильно выделяется - часть задач, связанных с рендерингом, находится в отдельной очереди.</p><p>Подробнее о главном цикле Chrome можно прочитать в <a href="https://habr.com/ru/post/461401/" title="habr.com">этой статье</a>. Я же просто приведу диаграмму оттуда.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/chrome-main-loop.png" alt="chrome-main-loop" /></p><p>То есть мы уже имеем целых три очереди на один цикл событий.</p><p>Если открыть инструменты разработчика в Chrome, то мы можем увидеть прекрасную картину работы главного (и не только) потока.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/chrome-tools-ex.png" alt="chrome-tools-ex" /></p><p>Сообщения из очереди <code class="language-plaintext highlighter-rouge">Render</code> здесь обозначены сиреневым цветом.</p><p>Если вас заинтересовала тема рендеринга, то вот <a href="https://www.alibabacloud.com/blog/exploration-of-the-flutter-rendering-mechanism-from-architecture-to-source-code_597285" title="alibabacloud.com">статья про рендеринг во Flutter, в которой есть сравнение с Chromium и Android SDK</a>.</p><h3 id="react-native">React Native</h3><p>Особенности главного цикла в React Native уходят корнями в логику потоков. Давайте взглянем на потоки <code class="language-plaintext highlighter-rouge">main</code> и <code class="language-plaintext highlighter-rouge">JsThread</code>:</p><ol><li><p><code class="language-plaintext highlighter-rouge">main</code> - старый, добрый, привычный. Именно в нём приложение начинает свою работу. Сначала он загружает пакеты JS, и после этого вся работа с JS ведётся в отдельном потоке. Main продолжает разве что просто обновлять View.</p><li><p><code class="language-plaintext highlighter-rouge">JsThread</code> - поток, в котором выполняется весь Javascript. В нём по сути происходит всё самое важное, что может случиться в React Native приложении. Обновления нативных view группируются, и отправляются в главный поток каждый оборот главного цикла.</p></ol><p>В итоге получается, что <code class="language-plaintext highlighter-rouge">MainThread</code> здесь используется только для отрисовки и чтобы загрузить JS. Вся логика происходит в <code class="language-plaintext highlighter-rouge">JsThread</code>, у которого есть собственный цикл. Так что на вопрос “Кто тут главный?” в рамках ReactNative ответить сложнее.</p><h3 id="kmm">KMM</h3><p>Сказать тут особо нечего, так как код Kotlin Native по сути вызывается из Android SDK, то логично, что главный цикл используется оттуда же. Тем не менее в KMM есть собственный <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/EventLoop.common.kt" title="github.com">EventLoop для корутин</a>, но главным циклом он, увы, не является.</p><h3 id="игры">Игры</h3><p>В играх главный цикл отличается больше всего. Основной его особенностью является то, что он работает всегда, загружая вашу систему насколько это позволяет движок. Ведь листики на деревьях должны двигаться в соответствии с ветром, даже если игрок никак в данный момент не взаимодействует с игрой.</p><p>Ну тут, хотя бы не надо так заморачиваться с ожиданием и пробуждением цикла. Всё должно быть проще, правда? Нет, не правда, на деле тут всё даже сложнее.</p><p>Итак, задача следующая - за один проход цикла нам надо:</p><ol><li>Считать ввод пользователя с экрана, геймпада или клавиатуры. Для этого сделаем метод <code class="language-plaintext highlighter-rouge">processInput</code>.<li>Просчитать физику, геометрию, поворот камеры, искусственный интеллект и пр. То есть в итоге мы должны получить позиции всех точек для полигонов. Пусть это делается в методе <code class="language-plaintext highlighter-rouge">updatePhysics</code>.<li>На основе точек отрисовать наши полигоны, наложить на них текстуры, шейдеры, отражения и пр., чтобы в конце выполнить растеризацию. Пусть это делается в методе <code class="language-plaintext highlighter-rouge">updateRender</code>.</ol><p>В нашем примере <code class="language-plaintext highlighter-rouge">processInput</code>, <code class="language-plaintext highlighter-rouge">updatePhysics</code>, <code class="language-plaintext highlighter-rouge">updateRender</code> - это просто методы, но в реальности используются привычные нам схемы с очередями и сообщениями. Так как мы уже достаточно разобрались как работают очереди, то в дальнейшем мы будем ими пренебрегать.</p><h4 id="подход-в-лобовую">Подход в лобовую</h4><p>Первое что приходит в голову - просто взять и запустить наши методы в бесконечном цикле, выглядеть это будет примерно следующим образом:</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">GameLooper</span> <span class="p">{</span>

   <span class="k">private</span> <span class="kd">var</span> <span class="py">isRunning</span> <span class="p">=</span> <span class="k">true</span>

   <span class="k">fun</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>

       <span class="k">while</span> <span class="p">(</span><span class="n">isRunning</span><span class="p">)</span> <span class="p">{</span>
           <span class="nf">processInput</span><span class="p">()</span>
           <span class="nf">updatePhysics</span><span class="p">()</span>
           <span class="nf">updateRender</span><span class="p">()</span>
       <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">private</span> <span class="k">fun</span> <span class="nf">processInput</span><span class="p">()</span> <span class="p">{</span>
       <span class="o">..................</span>
   <span class="p">}</span>

   <span class="k">private</span> <span class="k">fun</span> <span class="nf">updatePhysics</span><span class="p">()</span> <span class="p">{</span>
       <span class="o">..................</span>
   <span class="p">}</span>

   <span class="k">private</span> <span class="k">fun</span> <span class="nf">updateRender</span><span class="p">()</span> <span class="p">{</span>
       <span class="o">..................</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Ииииии… Это работает, но плохо. Главная проблема такого цикла в том, что он не привязан ко времени. По сути, чем мощнее железо телефона, тем быстрее будет выполняться наша игра, но если железо медленное, то игра будет идти наоборот очень медленно.</p><p>Чтобы понять почему это происходит давайте представим, что в нашей игре есть персонаж, и пока нажата кнопка «вперёд», он идет вперед (да да!!!). Делается это с помощью метода <code class="language-plaintext highlighter-rouge">walk</code>, который двигает нашего персонажа ровно на метр вперед. Обработка физики для этого метода занимает на слабом железе — допустим 1 секунду, а на мощном железе — 0,5 секунды.</p><p>Получается, что если пользователь жмёт на кнопку 3 секунды, то на медленном железе метод успеет выполниться 3 раза, а на мощном — 6. Соответственно, на мощном железе персонаж пройдет в два раза большее расстояние.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/android-main-loop/games-1.png" alt="games-1" /></p><p>В реальной же игре вообще все объекты будут двигаться в два раза быстрее. Согласитесь — такой геймплей нам не нужен.</p><p>Как же от этого избавиться?</p><h4 id="постоянное-количество-кадров">Постоянное количество кадров</h4><p>Проще всего взять и сделать количество кадров константным. Для этого выберем константу например — 25 кадров в секунду. Если же наша игра работает быстрее, чем 25 кадров в секунду, то вызывается старый добрый метод <code class="language-plaintext highlighter-rouge">Thread.sleep</code>, и наш цикл уснёт до тех пор, пока не придёт время нового кадра.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="k">const</span> <span class="kd">val</span> <span class="py">FRAMES_PER_SECOND</span> <span class="p">=</span> <span class="mi">25</span>
<span class="k">private</span> <span class="k">const</span> <span class="kd">val</span> <span class="py">SKIP_TICKS</span> <span class="p">=</span> <span class="mi">1000</span> <span class="p">/</span> <span class="nc">FRAMES_PER_SECOND</span>

<span class="kd">class</span> <span class="nc">GameLooper</span> <span class="p">{</span>

   <span class="k">private</span> <span class="kd">var</span> <span class="py">isRunning</span> <span class="p">=</span> <span class="k">true</span>

   <span class="k">fun</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
       <span class="kd">var</span> <span class="py">nextGameTick</span> <span class="p">=</span> <span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span>

       <span class="k">while</span> <span class="p">(</span><span class="n">isRunning</span><span class="p">)</span> <span class="p">{</span>
           <span class="nf">processInput</span><span class="p">()</span>
           <span class="nf">updatePhysics</span><span class="p">()</span>
           <span class="nf">updateRender</span><span class="p">()</span>

           <span class="n">nextGameTick</span> <span class="p">+=</span> <span class="nc">SKIP_TICKS</span>
           <span class="kd">val</span> <span class="py">sleepTime</span> <span class="p">=</span> <span class="n">nextGameTick</span> <span class="p">-</span> <span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span>
           <span class="k">if</span> <span class="p">(</span><span class="n">sleepTime</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
               <span class="nc">Thread</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">sleepTime</span><span class="p">)</span>
           <span class="p">}</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Такое решение лучше предыдущего, на среднем и мощном железе оно будет работать с одинаковой скоростью. И на этом плюсы этого решения заканчиваются.</p><p>Проблема с тем, что на слабом железе наша игра работает медленно, никуда не ушла. Получается эдакое лагающее slo-mo, <a href="https://www.youtube.com/watch?v=7kYnoIIED1o" title="youtube.com">такое можно заметить например в Dark Souls</a>.</p><p>С мощным железом всё тоже не очень хорошо. По факту, оно простаивает большую часть времени, просто находясь в ожидании времени наступления следующего кадра. Хотя и у этого решения есть плюсы - меньше расходуется батарея на телефоне. Но всё же, чем мощнее железо, тем больше оно спит.</p><p>Это не очень хорошо, ведь пользователь покупал мощный телефон со 120 Гц экраном не для того, чтобы быть ограниченным 25 кадрами. Поэтому займемся проблемами скорости игры.</p><h4 id="реальное-время">Реальное время</h4><p>Если задуматься, то станет очевидно, что такие вещи, как звуки и анимации, завязаны на реальном времени. Звук должен проигрываться определённое количество времени независимо от мощности железа. Почему бы и в случае с графикой тогда не смотреть на реальное время и уже подстраиваться под него.</p><p>Правда придётся переписать все расчёты физики, чтобы они учитывали время, так что хорошо, что наш проект гипотетический. Мы просто будем прокидывать время, которое прошло с предыдущего кадра, прямо в метод <code class="language-plaintext highlighter-rouge">updatePhysics</code> и уже в самих расчетах отталкиваться от количества времени которое прошло.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">GameLooper</span> <span class="p">{</span>

   <span class="k">private</span> <span class="kd">var</span> <span class="py">isRunning</span> <span class="p">=</span> <span class="k">true</span>

   <span class="k">fun</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
       <span class="kd">var</span> <span class="py">currentFrameTick</span> <span class="p">=</span> <span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span>

       <span class="k">while</span> <span class="p">(</span><span class="n">isRunning</span><span class="p">)</span> <span class="p">{</span>
           <span class="kd">val</span> <span class="py">prevFrameTick</span> <span class="p">=</span> <span class="n">currentFrameTick</span>
           <span class="n">currentFrameTick</span> <span class="p">=</span> <span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span>


           <span class="nf">processInput</span><span class="p">()</span>
           <span class="nf">updatePhysics</span><span class="p">(</span><span class="n">currentFrameTick</span> <span class="p">-</span> <span class="n">prevFrameTick</span><span class="p">)</span>
           <span class="nf">updateRender</span><span class="p">()</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>В итоге наша игра идёт с одинаковой скоростью независимо от мощности железа (не считая совсем уж низкий FPS). Первая победа!</p><p>Этот вариант кажется практически идеальным, но у него есть и минусы.</p><p>На слабом железе всё достаточно хорошо. Конечно если FPS будет совсем уж низким - 10-15 кадров в секунду, то управлять игрой станет практически невозможно, так как в отличии от предыдущих вариантов игра не замедляется давая игроку возможность сориентироваться. Но откровенно говоря играть на таком FPS практически невозможно при любом цикле событий.</p><p>На мощном железе может происходить магия. В чём она заключается? Ну, возможно, некоторые объекты будут летать (а не должны), что-то двигаться слишком быстро, а что-то слишком медленно. В чем же причина такой магии? В дробных числах.</p><p>Дробные числа, вроде <code class="language-plaintext highlighter-rouge">Float</code> или <code class="language-plaintext highlighter-rouge">Double</code>, имеют фиксированное количество цифр после запятой и вообще не являются идеально точными. Например, 0.1 может оказаться как 0,10000000000000001, так и 0,99999999999999976. Для примера давайте возьмём простой код:</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">println</span><span class="p">(</span><span class="s">"%f"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="mf">1f</span> <span class="p">*</span> <span class="mi">1_000_000_000_000</span><span class="p">))</span>
</pre></table></code></div></div><p>Мы просто взяли единицу формата <code class="language-plaintext highlighter-rouge">Float</code> и умножили на очень большое число. В итоге нам выведется 999999995904.000000. Погрешность стала уже достаточно большой.</p><p>Обычно это не вызывает проблем. Но допустим у нас есть гусеница, которая проползает 0.0001 метра в секунду. При 30 кадров в секунду мы должны будем подвинуть гусеницу на 1/30 от этого расстояния - 0,0000033, при 120 уже на 1/120 - 0,000000833. Чем выше FPS тем меньшими дробями нам приходится оперировать и тем сильнее может сказываться погрешность. Очень наглядным примером является Skyrim, <a href="https://www.youtube.com/watch?v=ZFVtXjr-Nno" title="youtube.com">который при высокой частоте кадров начинает запускать телеги в воздух</a>.</p><p>Не факт, что конкретно в вашей игре погрешность <code class="language-plaintext highlighter-rouge">Float</code> на что-то повлияет, но это одна из тех вещей, которая может с вами случиться. Избавиться от этого можно просто стараясь не использовать очень малые дроби. Но, так как у нас тут статья про главный цикл, давайте попробуем исправить это за счёт изменения цикла.</p><p>Да и в целом, <a href="https://gafferongames.com/post/fix_your_timestep/" title="gafferongames.com">физические движки любят постоянство</a>.</p><h4 id="постоянство-шрёдингера">Постоянство Шрёдингера</h4><p>Раз проблема с погрешностью <code class="language-plaintext highlighter-rouge">Float</code> проявляет себя в первую очередь в расчётах физики, то давайте зададим ей постоянную частоту обновления, а отрисовка пусть происходит так часто, как это вообще возможно. Получится одновременно и постоянная частота и не постоянная.</p><p>Условимся, что наша физика должна рассчитываться 50 раз в секунду. Путём несложных вычислений мы понимаем, что рассчитывать физику мы должны каждые 20 миллисекунд. Поэтому в цикле мы просто проверяем, что если с момента последнего обновления физики прошло более чем 20 миллисекунд, то её нужно обновить.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="k">const</span> <span class="kd">val</span> <span class="py">TICKS_PER_SECOND</span> <span class="p">=</span> <span class="mi">50</span>
<span class="k">private</span> <span class="k">const</span> <span class="kd">val</span> <span class="py">SKIP_TICKS</span> <span class="p">=</span> <span class="mi">1000</span> <span class="p">/</span> <span class="nc">TICKS_PER_SECOND</span>
<span class="kd">class</span> <span class="nc">GameLooper</span> <span class="p">{</span>

   <span class="k">private</span> <span class="kd">var</span> <span class="py">isRunning</span> <span class="p">=</span> <span class="k">true</span>

   <span class="k">fun</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
       <span class="kd">var</span> <span class="py">nextGameTick</span> <span class="p">=</span> <span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span>

       <span class="k">while</span> <span class="p">(</span><span class="n">isRunning</span><span class="p">)</span> <span class="p">{</span>
           <span class="kd">val</span> <span class="py">needUpdate</span> <span class="p">=</span> <span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span> <span class="p">&gt;</span> <span class="n">nextGameTick</span>
           <span class="k">if</span> <span class="p">(</span><span class="n">needUpdate</span><span class="p">)</span> <span class="p">{</span>
               <span class="nf">processInput</span><span class="p">()</span>
               <span class="nf">updatePhysics</span><span class="p">()</span>

               <span class="n">nextGameTick</span> <span class="p">+=</span> <span class="nc">SKIP_TICKS</span>
           <span class="p">}</span>

           <span class="nf">updateRender</span><span class="p">()</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Вывод изображения на экран с помощью <code class="language-plaintext highlighter-rouge">updateRender</code> мы делаем так часто, как можем. Теперь игра должна ощущаться плавнее, так как многие эффекты, шейдеры, частицы и пр. будут обрабатываться настолько быстро, насколько это возможно.</p><p>Но в играх время отрисовки кадров неодинаково, и может быть ситуация, когда какой-то кадр обрабатывался в <code class="language-plaintext highlighter-rouge">updateRender</code> сильно дольше обычного - к примеру 65 мс. Тогда обработка физики вместо того, чтобы выполниться 3 раза, выполнится всего один раз. В целом таких кадров может быть много. Из-за этого и так не слабенькое подтормаживание ощущается еще сильнее.</p><p>Поэтому надо научить физику “догонять”. Для этого мы вставим еще один цикл <code class="language-plaintext highlighter-rouge">while</code>, вместо <code class="language-plaintext highlighter-rouge">if</code>.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="k">const</span> <span class="kd">val</span> <span class="py">TICKS_PER_SECOND</span> <span class="p">=</span> <span class="mi">50</span>
<span class="k">private</span> <span class="k">const</span> <span class="kd">val</span> <span class="py">SKIP_TICKS</span> <span class="p">=</span> <span class="mi">1000</span> <span class="p">/</span> <span class="nc">TICKS_PER_SECOND</span>

<span class="kd">class</span> <span class="nc">GameLooper</span> <span class="p">{</span>

   <span class="k">private</span> <span class="kd">var</span> <span class="py">isRunning</span> <span class="p">=</span> <span class="k">true</span>

   <span class="k">fun</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
       <span class="kd">var</span> <span class="py">nextGameTick</span> <span class="p">=</span> <span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span>

       <span class="k">while</span> <span class="p">(</span><span class="n">isRunning</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">while</span> <span class="p">(</span><span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span> <span class="p">&gt;</span> <span class="n">nextGameTick</span><span class="p">)</span> <span class="p">{</span>
               <span class="nf">processInput</span><span class="p">()</span>
               <span class="nf">updatePhysics</span><span class="p">()</span>

               <span class="n">nextGameTick</span> <span class="p">+=</span> <span class="nc">SKIP_TICKS</span>
           <span class="p">}</span>

           <span class="nf">updateRender</span><span class="p">()</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Теперь новый кадр не будет отрисовываться, пока физика не догонит текущее время.</p><p>Пришло время разобраться с <code class="language-plaintext highlighter-rouge">updateRender</code>. Так как между вызовами <code class="language-plaintext highlighter-rouge">updateRender</code> физика может и не обновиться, то получится ситуация когда большая часть объектов в кадре не изменится. С этим нужно что-то сделать. Решение есть - интерполяция!</p><p>Допустим, с последнего обновления физики прошло 10 мс, время между обновлениями физики 20 мс. По сути мы просто делим 10 на 20 тем самым получив ½. То есть с последнего обновления физики прошла примерно половина времени кадра. ½ и будет нашим значением интерполяции. При отрисовке кадра мы можем например умножить вектора движений на это значение. Таким образом наша игра станет гораздо плавнее.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="k">const</span> <span class="kd">val</span> <span class="py">TICKS_PER_SECOND</span> <span class="p">=</span> <span class="mi">50</span>
<span class="k">private</span> <span class="k">const</span> <span class="kd">val</span> <span class="py">SKIP_TICKS</span> <span class="p">=</span> <span class="mi">1000</span> <span class="p">/</span> <span class="nc">TICKS_PER_SECOND</span>

<span class="kd">class</span> <span class="nc">GameLooper</span> <span class="p">{</span>

   <span class="k">private</span> <span class="kd">var</span> <span class="py">isRunning</span> <span class="p">=</span> <span class="k">true</span>

   <span class="k">fun</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
       <span class="kd">var</span> <span class="py">nextGameTick</span> <span class="p">=</span> <span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span>

       <span class="k">while</span> <span class="p">(</span><span class="n">isRunning</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">while</span> <span class="p">(</span><span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span> <span class="p">&gt;</span> <span class="n">nextGameTick</span><span class="p">)</span> <span class="p">{</span>
               <span class="nf">processInput</span><span class="p">()</span>
               <span class="nf">updatePhysics</span><span class="p">()</span>

               <span class="n">nextGameTick</span> <span class="p">+=</span> <span class="nc">SKIP_TICKS</span>
           <span class="p">}</span>
           <span class="kd">val</span> <span class="py">time</span> <span class="p">=</span> <span class="nc">SystemClock</span><span class="p">.</span><span class="nf">uptimeMillis</span><span class="p">()</span> <span class="p">+</span> <span class="nc">SKIP_TICKS</span> <span class="p">-</span> <span class="n">nextGameTick</span>
           <span class="kd">val</span> <span class="py">interpolation</span> <span class="p">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">toFloat</span><span class="p">()</span> <span class="p">/</span> <span class="nc">SKIP_TICKS</span>
           <span class="nf">updateRender</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Так, а разве у нас опять не возникнет проблема с погрешностью <code class="language-plaintext highlighter-rouge">Float</code>? Мы ведь опять что-то делим.</p><p>Вообще, так как минимальным шагом в наших вычислениях является миллисекунда, то в наихудшем случае мы будем делить 1 на 20. А 1/20 не очень страшная дробь. К тому же, <code class="language-plaintext highlighter-rouge">updateRender</code> лишь выводит изображение, и небольшая погрешность в нем навредит не так сильно, как в расчётах физики или положения объектов.</p><p>Последний вариант не является «серебрянной пулей» хоть и достаточно оптимален. В разных ситуациях могут пригодиться разные варианты циклов. Всё очень зависит от конкретной игры. Для соревновательных игр типа CS:GO или Valorant хочется обновлять мир и физику как можно чаще, на это и стоит делать упор. А также есть VR, в котором надо отрендерить не одну картинку, а две, причём не меньше 90 фпс, а лучше 120, иначе будет тошнить. А если уж в игре есть перемотка времени… В реальных игровых движках в таком цикле гораздо больше действий и итераций. Можете оценить <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html" title="docs.unity3d.com">как это выглядит в Unity</a>. Если хотите поглубже погрузиться в океан главных циклов в играх, то вот <a href="http://gameprogrammingpatterns.com/game-loop.html" title="gameprogrammingpatterns.com">хорошая статья</a> и <a href="https://dewitters.com/dewitters-gameloop/" title="dewitters.com">вот еще тоже</a>.</p><p>Также мы не рассмотрели такой важный фактор, как постоянство кадровой частоты. Она тоже очень сильно влияет на ощущение плавности, но это отдельная и очень глубокая тема, для тех кто хочет в неё погрузиться, я тоже нашел <a href="https://www.kinematicsoup.com/news/2016/8/9/rrypp5tkubynjwxhxjzd42s3o034o8" title="kinematicsoup.com">хорошую статью</a> (она ещё и с gif’ками!!!).</p><hr /><h2 id="полезные-ссылки">Полезные ссылки</h2><p><strong>Ссылки на оригинальные статьи:</strong><br /> <a href="https://habr.com/ru/company/cian/blog/588314/" title="habr.com">Main Loop (Главный цикл) в Android Часть 1. Пишем свой цикл</a><br /> <a href="https://habr.com/ru/company/cian/blog/589827/" title="habr.com">Main Loop (Главный цикл) в Android Часть 2. Android SDK</a><br /> <a href="https://habr.com/ru/company/cian/blog/591877/" title="habr.com">Main Loop (Главный цикл) в Android Часть 3. Другие главные циклы</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/android/'>Android</a>, <a href='/categories/theory/'>Theory</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >android</a> <a href="/tags/theory/" class="post-tag no-text-decoration" >theory</a> <a href="/tags/main-loop/" class="post-tag no-text-decoration" >main loop</a> <a href="/tags/%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D1%8B%D0%B9-%D1%86%D0%B8%D0%BA%D0%BB/" class="post-tag no-text-decoration" >главный цикл</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Поделиться</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text='Main Loop (Главный цикл) в Android' - Bimlibik&url=http://bimlibik.github.io/posts/android-main-loop/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title='Main Loop (Главный цикл) в Android' - Bimlibik&u=http://bimlibik.github.io/posts/android-main-loop/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text='Main Loop (Главный цикл) в Android' - Bimlibik&url=http://bimlibik.github.io/posts/android-main-loop/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Последние обновления</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/about-android/">Что такое Android</a><li><a href="/posts/kotlin-inline-functions/">Kotlin. Встроенные (inline) функции</a><li><a href="/posts/kotlin-collections/">Kotlin. Коллекции</a><li><a href="/posts/kotlin-overview/">Kotlin. Общий обзор</a><li><a href="/posts/kotlin-sealed-classes/">Kotlin. Изолированные (запечатанные) классы (sealed classes).</a></ul></div><div id="access-tags"> <span>Популярные теги</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/theory/">theory</a> <a class="post-tag" href="/tags/kotlin/">kotlin</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/basics/">basics</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/android-version/">android version</a> <a class="post-tag" href="/tags/ui/">ui</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/history/">history</a> <a class="post-tag" href="/tags/oop/">oop</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Содержание</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Недавно просмотренное</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/android-obfuscation/"><div class="card-body"> <span class="timeago small" > 11 January 2021 <i class="unloaded">2021-01-11T01:14:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Обфускация кода</h3><div class="text-muted small"><p> Защита кода приложения это то, о чем не всегда задумывается разработчик. Но  ведь обфускация при сборке – это не только защита. Это также эффективный способ уменьшить размер конечного APK, а иногда...</p></div></div></a></div><div class="card"> <a href="/posts/how-does-android-work/"><div class="card-body"> <span class="timeago small" > 21 May 2020 <i class="unloaded">2020-05-21T04:20:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Как работает Android. Архитектура платформы</h3><div class="text-muted small"><p> Думаю, что каждому начинающему разработчику тяжело понять как Android устроен и в принципе из чего он состоит. В этой статье я постараюсь наиболее детально и понятно расписать как система Android с...</p></div></div></a></div><div class="card"> <a href="/posts/manifest-file/"><div class="card-body"> <span class="timeago small" > 31 May 2020 <i class="unloaded">2020-05-31T21:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Манифест приложения</h3><div class="text-muted small"><p> Манифест - это набор правил, по которым работает приложение. Файл манифеста находится в корневой папке - AndroidManifest.xml - и содержит важную информацию, без которой система не сможет запустить ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/kotlin-collections/" class="btn btn-outline-primary" prompt="Предыдущая статья"><p>Kotlin. Коллекции</p></a> <span class="btn btn-outline-primary disabled" prompt="Следующая статья"><p>-</p></span></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Bimlibik">Bimlibik</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Популярные теги</h4><a class="post-tag" href="/tags/theory/">theory</a> <a class="post-tag" href="/tags/kotlin/">kotlin</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/basics/">basics</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/android-version/">android version</a> <a class="post-tag" href="/tags/ui/">ui</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/history/">history</a> <a class="post-tag" href="/tags/oop/">oop</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="http://bimlibik.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
