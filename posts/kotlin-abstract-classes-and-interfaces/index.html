<!DOCTYPE html><html lang="ru-RU" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Kotlin. Абстрактные классы и интерфейсы." /><meta name="author" content="Leslie M." /><meta property="og:locale" content="ru_RU" /><meta name="description" content="Абстрактные классы и интерфейсы объединены мной в одну тему, так как по своей сути они очень похожи. И те и другие имеют отношение к “моделированию” классов. С их помощью мы можем показать, что у определённой группы классов есть что-то общее: то, что их отличает от всех остальных. Ключевая разница между ними лишь в том, как их применять." /><meta property="og:description" content="Абстрактные классы и интерфейсы объединены мной в одну тему, так как по своей сути они очень похожи. И те и другие имеют отношение к “моделированию” классов. С их помощью мы можем показать, что у определённой группы классов есть что-то общее: то, что их отличает от всех остальных. Ключевая разница между ними лишь в том, как их применять." /><link rel="canonical" href="http://bimlibik.github.io/posts/kotlin-abstract-classes-and-interfaces/" /><meta property="og:url" content="http://bimlibik.github.io/posts/kotlin-abstract-classes-and-interfaces/" /><meta property="og:site_name" content="Bimlibik" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-07T20:40:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Kotlin. Абстрактные классы и интерфейсы." /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Leslie M." /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Абстрактные классы и интерфейсы объединены мной в одну тему, так как по своей сути они очень похожи. И те и другие имеют отношение к “моделированию” классов. С их помощью мы можем показать, что у определённой группы классов есть что-то общее: то, что их отличает от всех остальных. Ключевая разница между ними лишь в том, как их применять.","headline":"Kotlin. Абстрактные классы и интерфейсы.","dateModified":"2020-07-07T20:40:00+08:00","datePublished":"2020-07-07T20:40:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://bimlibik.github.io/posts/kotlin-abstract-classes-and-interfaces/"},"url":"http://bimlibik.github.io/posts/kotlin-abstract-classes-and-interfaces/","author":{"@type":"Person","name":"Leslie M."},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>Kotlin. Абстрактные классы и интерфейсы. | Bimlibik</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-159618579-2"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-159618579-2'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Bimlibik</a></div><div class="site-subtitle font-italic">База статей по Android и Kotlin.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>ГЛАВНАЯ</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>КАТЕГОРИИ</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>ТЕГИ</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>АРХИВ</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>О САЙТЕ</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Bimlibik" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Статьи </a> </span> <span>Kotlin. Абстрактные классы и интерфейсы.</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Поиск..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Kotlin. Абстрактные классы и интерфейсы.</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="07.07.2020, 20:40" prefix="Опубликовано " > 07 July 2020 <i class="unloaded">2020-07-07T20:40:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="Всего слов - 1463"> Время чтения 8 мин. </span></div></div><div class="post-content"><p>Абстрактные классы и интерфейсы объединены мной в одну тему, так как по своей сути они очень похожи. И те и другие имеют отношение к “моделированию” классов. С их помощью мы можем показать, что у определённой группы классов есть что-то общее: то, что их отличает от всех остальных. Ключевая разница между ними лишь в том, как их применять.</p><h2 id="абстрактные-классы">Абстрактные классы</h2><p>Абстрактный класс - это класс, представляющий из себя “заготовку” для целого семейства классов, который описывает для них общий шаблон поведения. Такой класс не может быть создан. Т.е. нельзя создать его экземпляр. Он используются исключительно в качестве суперкласса, а его цель - моделирование поведения своего семейства, а также предоставление функционала для повторного использования. Другими словами абстрактный класс - это средство, для повторного использования кода.</p><p>Например, вы разрабатываете приложение, которое предоставляет информацию о деревьях. Тогда класс <code class="language-plaintext highlighter-rouge">Tree</code> должен быть абстрактным и объединять в себе свойства и функции, характерные для всех деревьев. А каждый наследник класса <code class="language-plaintext highlighter-rouge">Tree</code> будет по-своему их реализовывать.</p><p>Объявляется абстрактный класс при помощи ключевого слова <code class="language-plaintext highlighter-rouge">abstract</code>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>abstract class Tree {
  ...
}
</pre></table></code></div></div><p>Наследование от такого класса осуществляется с помощью оператора <code class="language-plaintext highlighter-rouge">:</code>. При этом абстрактному классу не нужен модификатор <a href="https://bimlibik.github.io/posts/kotlin-open-keyword/"><code class="language-plaintext highlighter-rouge">open</code></a>, потому что он “открыт” для наследования по умолчанию.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>class Pine : Tree() {
  ...
}
</pre></table></code></div></div><p>В теле класса можно объявлять абстрактные свойства и функции. Это полезно, когда часть поведения класса не имеет смысла без реализации в более конкретном подклассе.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>abstract class Tree {
  abstract val name: String
  abstract val description: String
  abstract fun info()
}
</pre></table></code></div></div><p>Каждый наследник обязан переопределять их все.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>class Pine : Tree() {
  override val name = "Сосна"
  override val description = "Хвойное дерево с длинными иглами и округлыми шишками"
  override fun info() = "$name - ${description.toLowerCase()}."  
}
</pre></table></code></div></div><p>Свойства и функции необязательно должны быть абстрактными. У них может быть обобщенная реализация, которая будет с пользой наследоваться всеми подклассами. В этом случае для них в абстрактном классе объявляется конкретная реализация, к которой имеют доступ все наследники.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>abstract class Tree {
  abstract val name: String
  abstract val description: String
  fun info(): String = "$name - ${description.toLowerCase()}."
}

...

class Pine : Tree() {
  override val name = "Сосна"
  override val description = "Хвойное дерево с длинными иглами и округлыми шишками"
}

...

val pine = Pine()
println(pine.info())
</pre></table></code></div></div><p>Так как этот компонент класса уже не будет абстрактным, наследники не смогут его переопределить.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>class Pine : Tree() {
  override val name = "Сосна"
  override val description = "Хвойное дерево с длинными иглами и округлыми шишками"

  // ошибка: функция "info" является "final" и не может быть переопределена
  override fun info() = description  
}
</pre></table></code></div></div><p>Чтобы это исправить нужно явно задать модификатор <a href="https://bimlibik.github.io/posts/kotlin-open-keyword/"><code class="language-plaintext highlighter-rouge">open</code></a> для функции с конкретной реализацией. Тогда у наследников появляется выбор: либо не переопределять функцию и использовать реализацию суперкласса, либо переопределить и указать свою собственную реализацию.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>abstract class Tree {
  abstract val name: String
  abstract val description: String

  open fun info(): String = "$name - ${description.toLowerCase()}."
}
</pre></table></code></div></div><p>У абстрактного класса может быть конструктор.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>abstract class Tree(val name: String, val description: String) {
  open fun info(): String = "$name - ${description.toLowerCase()}."
}
</pre></table></code></div></div><p>Тогда каждый наследник должен предоставить для него значения.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>class Pine(name: String, description: String) : Tree(name, description)

...

val pine = Pine("Сосна", "Хвойное дерево с длинными иглами и округлыми шишками")
println(pine.info())
</pre></table></code></div></div><hr /><h2 id="интерфейсы">Интерфейсы</h2><p>Интерфейс - это совокупность методов и правил, которые определяют <strong>поведение</strong> класса или <strong>общее поведение</strong> для группы независимых друг от друга классов. Интерфейсы похожи на абстрактные классы тем, что нельзя создать их экземпляры и они могут определять абстрактные или конкретные функции и свойства. Отличие в том, что интерфейсу не важна связь “родитель-наследник”, он задаёт лишь правила поведения.</p><p>К примеру, в нашем приложении уже есть целое семейство деревьев, информацию о которых можно с лёгкостью получить - их название и краткое описание. Но помимо этого деревья могут цвести и производить кислород. Такие методы можно добавить в абстрактный класс <code class="language-plaintext highlighter-rouge">Tree</code>, но что если мы решим помимо деревьев предоставлять информацию о, скажем, водорослях. У них тоже есть период цветения и они тоже производят кислород, но они <strong>не являются</strong> деревьями, а значит мы не можем наследовать их от класса <code class="language-plaintext highlighter-rouge">Tree</code>. Таким образом мы получили группу независимых друг от друга классов с одинаковым поведением, которое будет реализовываться через интерфейс <code class="language-plaintext highlighter-rouge">Cultivable</code>.</p><p>Объявляется интерфейс ключевым словом <code class="language-plaintext highlighter-rouge">interface</code>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>interface Cultivable {
  ...
}
</pre></table></code></div></div><p>Реализация интерфейса осуществляется аналогично наследованию: после имени класса ставится оператор <code class="language-plaintext highlighter-rouge">:</code> и название интерфейса.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>abstract class Tree : Cultivable {
  ...
}

class Seaweed : Cultivable {
  ...
}
</pre></table></code></div></div><p>В теле интерфейса можно определять абстрактные свойства и функции. Для этого не требуется использовать ключевое слово <code class="language-plaintext highlighter-rouge">abstract</code>, так как Kotlin способен сам понять, что свойство и функция без реализации должны быть абстрактными. Также обратите внимание, что единственный способ определить свойство - это определить его в теле интерфейса, так как у интерфейса не бывает конструкторов.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>interface Cultivable {
  val bloom: Boolean
  fun startPhotosynthesis()
}
</pre></table></code></div></div><p>Класс должен реализовывать все абстрактные свойства и функции, определённые в интерфейсе.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>abstract class Tree : Cultivable {
  abstract val name: String
  abstract val description: String
  open fun info(): String = "$name - ${description.toLowerCase()}."

  override val bloom = false
  override fun startPhotosynthesis() {
    ...
  }
}
</pre></table></code></div></div><p>При этом если интерфейс реализовывается в абстрактном классе, то свойства и функции интерфейса могут быть в нём опущены. Тогда все наследники абстрактного класса должны будут их переопределять.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>abstract class Tree : Cultivable {
  abstract val name: String
  abstract val description: String
  open fun info(): String = "$name - ${description.toLowerCase()}."

  override fun startPhotosynthesis() {
    ...
  }
}

class Pine : Tree() {
  override val name = "Сосна"
  override val description = "Хвойное дерево с длинными иглами и округлыми шишками"

  override val bloom = false
}
</pre></table></code></div></div><p>В интерфейсе можно определять свойства и функции с конкретной реализацией (по умолчанию). Классы, реализующие этот интерфейс, могут использовать реализацию по умолчанию или определить свою. При этом реализация свойств осуществляется с помощью метода доступа <code class="language-plaintext highlighter-rouge">get()</code>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>interface Cultivable {
  val bloom: Boolean
    get() = false

  fun startPhotosynthesis() {
    ...
  }
}
</pre></table></code></div></div><p>Один интерфейс может реализовать другой интерфейс, при этом будет иметь доступ к его свойствам и функциям.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>interface Fruitable {
  val fruit: String
    get() = "неплодоносный"
}

interface Cultivable : Fruitable {
  ...

  fun isFruitable() : Boolean {
    if(fruit == "неплодоносный") return false
    return true
  }
}
</pre></table></code></div></div><p>Каждый класс, реализующий интерфейс <code class="language-plaintext highlighter-rouge">Cultivable</code> может использовать свойства и функции интерфейса <code class="language-plaintext highlighter-rouge">Fruitable</code>, если в этом есть необходимость.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>class AppleTree() : Tree() {
  override val name = "Яблоня"
  override val description = "Фруктовое дерево"
  override val fruit = "яблоко"
}

...

val appleTree = AppleTree()
if(appleTree.isFruitable()) {
  println("Плод - ${appleTree.fruit}.")
} else {
  println("${appleTree.name} не плодоносит.")
}
</pre></table></code></div></div><hr /><h2 id="шпаргалка-абстрактный-класс-или-интерфейс">Шпаргалка: абстрактный класс или интерфейс?</h2><ul><li>У вас есть семейство классов, из которых можно выделить общую сущность? Определите эту сущность в качестве абстрактного класса и она будет “заготовкой” для всего семейства.<li>Вам нужно создать более конкретную версию класса? Создайте подкласс этого класса и добавьте недостающее поведение.<li>Требует определить общее поведение для группы независимых друг от друга классов? Создайте интерфейс и реализуйте его теми классами, которым необходимо это поведение.</ul><hr /><h2 id="ключевые-моменты">Ключевые моменты</h2><ul><li>Абстрактный класс - это “заготовка” для целого семейства классов.<li>Нельзя создать экземпляр абстрактного класса.<li>Абстрактный класс может содержать как абстрактные, так и конкретные реализации свойств и функций.<li>Класс, который содержит абстрактное свойство или функцию, должен быть объявлен абстрактным.<li>Абстрактный класс может быть без единого абстрактного свойства или функции.<li>У класса может быть только один суперкласс.<li>Наследники абстрактного класса должны переопределять все его абстрактные свойства и функции.<li>Чтобы наследники могли переопределять конкретные реализации свойств и функций, для них в абстрактном классе должен быть явно указан модификатор <a href="https://bimlibik.github.io/posts/kotlin-open-keyword/"><code class="language-plaintext highlighter-rouge">open</code></a>.<li>У абстрактного класса может быть конструктор.<li>Интерфейс определяет поведение класса или общее поведение для группы независимых друг от друга классов.<li>Нельзя создать экземпляр интерфейса.<li>Интерфейс может содержать как абстрактные, так и конкретные реализации функций.<li>Свойства интерфейсов могут быть абстрактными, а могут иметь <code class="language-plaintext highlighter-rouge">get()</code> методы.<li>Класс может реализовывать несколько интерфейсов.<li>Класс должен реализовывать все абстрактные свойства и функции, определённые в интерфейсе.<li>Если интерфейс реализовывается абстрактным классом, то переопределение его абстрактных свойств и функций может быть передана наследникам абстрактного класса.<li>Интерфейс может реализовывать другой интерфейс.</ul><hr /><h2 id="полезные-ссылки">Полезные ссылки</h2><p><a href="https://kotlinlang.org/docs/reference/classes.html#abstract-classes" title="kotlinlang.org">Abstract classes</a> - официальная документация.<br /> <a href="https://kotlinlang.ru/docs/reference/classes.html" title="kotlinlang.ru">Абстрактные классы</a> - перевод на русский (об абстрактных классах в самом низу статьи).<br /> <a href="https://kotlinlang.org/docs/reference/interfaces.html" title="kotlinlang.org">Interfaces</a> - официальная документация.<br /> <a href="https://kotlinlang.ru/docs/reference/interfaces.html" title="kotlinlang.ru">Интерфейсы</a> - перевод статьи про интерфейсы на русский.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/kotlin/'>Kotlin</a>, <a href='/categories/classes-and-objects/'>Classes and Objects</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kotlin/" class="post-tag no-text-decoration" >kotlin</a> <a href="/tags/theory/" class="post-tag no-text-decoration" >theory</a> <a href="/tags/abstract-class/" class="post-tag no-text-decoration" >abstract class</a> <a href="/tags/interfaces/" class="post-tag no-text-decoration" >interfaces</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Поделиться</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text='Kotlin. Абстрактные классы и интерфейсы.' - Bimlibik&url=http://bimlibik.github.io/posts/kotlin-abstract-classes-and-interfaces/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title='Kotlin. Абстрактные классы и интерфейсы.' - Bimlibik&u=http://bimlibik.github.io/posts/kotlin-abstract-classes-and-interfaces/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text='Kotlin. Абстрактные классы и интерфейсы.' - Bimlibik&url=http://bimlibik.github.io/posts/kotlin-abstract-classes-and-interfaces/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Последние обновления</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/about-android/">Что такое Android</a><li><a href="/posts/kotlin-inline-functions/">Kotlin. Встроенные (inline) функции</a><li><a href="/posts/kotlin-collections/">Kotlin. Коллекции</a><li><a href="/posts/kotlin-overview/">Kotlin. Общий обзор</a><li><a href="/posts/kotlin-sealed-classes/">Kotlin. Изолированные (запечатанные) классы (sealed classes).</a></ul></div><div id="access-tags"> <span>Популярные теги</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/theory/">theory</a> <a class="post-tag" href="/tags/kotlin/">kotlin</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/basics/">basics</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/android-version/">android version</a> <a class="post-tag" href="/tags/ui/">ui</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/history/">history</a> <a class="post-tag" href="/tags/oop/">oop</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Содержание</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Недавно просмотренное</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/kotlin-data-classes/"><div class="card-body"> <span class="timeago small" > 22 June 2020 <i class="unloaded">2020-06-22T21:30:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Kotlin. Классы данных (Data classes)</h3><div class="text-muted small"><p> В процессе разработки нам часто приходится создавать классы, предназначенные исключительно для хранения каких-либо данных. При этом, чтобы такой класс стал максимально удобным переопределяются мето...</p></div></div></a></div><div class="card"> <a href="/posts/kotlin-nested-and-inner-clesses/"><div class="card-body"> <span class="timeago small" > 23 June 2020 <i class="unloaded">2020-06-23T18:50:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Kotlin. Вложенные и внутренние классы</h3><div class="text-muted small"><p> В Kotlin можно объявить один класс внутри другого. Как правило это полезно, когда нужно расширить функционал внешнего класса: будет чёткое разделение прямого предназначения класса от новой функцион...</p></div></div></a></div><div class="card"> <a href="/posts/kotlin-sealed-classes/"><div class="card-body"> <span class="timeago small" > 25 June 2020 <i class="unloaded">2020-06-25T15:50:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Kotlin. Изолированные (запечатанные) классы (sealed classes).</h3><div class="text-muted small"><p> Изолированный класс - это еще одно новшество в языке Kotlin, которого не было в Java. Тем не менее, само по себе понятие в программировании не является новым — Kotlin позаимствовал его у других язы...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/android-activity/" class="btn btn-outline-primary" prompt="Предыдущая статья"><p>Activity (Активность, Операция)</p></a> <a href="/posts/recycler-view/" class="btn btn-outline-primary" prompt="Следующая статья"><p>RecyclerView</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Bimlibik">Bimlibik</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Популярные теги</h4><a class="post-tag" href="/tags/theory/">theory</a> <a class="post-tag" href="/tags/kotlin/">kotlin</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/basics/">basics</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/android-version/">android version</a> <a class="post-tag" href="/tags/ui/">ui</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/history/">history</a> <a class="post-tag" href="/tags/oop/">oop</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="http://bimlibik.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
