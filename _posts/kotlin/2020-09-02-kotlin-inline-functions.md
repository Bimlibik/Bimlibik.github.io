---
title: Kotlin. Встроенные (inline) функции
author: Leslie M.
date: "2020-09-02 20:30:00 +0800"
categories: [Kotlin, Functions]
tags: [kotlin, theory, inline functions, inline, reified]
---

В Kotlin существует модификатор `inline`, которым можно пометить функцию. Основное его предназначение - повысить производительность. Чтобы понять за счёт чего она повышается, нужно вспомнить лямбда-выражения.

Как правило, лямбда-выражения компилируются в анонимные классы. То есть каждый раз, когда используется лямбда-выражение, создаётся дополнительный класс. Отсюда вытекают дополнительные накладные расходы у функций, которые принимают лямбду в качестве аргумента. Если же функцию отметить модификатором `inline`, то компилятор не будет создавать анонимные классы и их объекты для каждого лямбда-выражения, а просто вставит код её реализации в место вызова. Или другими словами **встроит** её.

```
inline fun <T> lock(lock: Lock, body: () -> T): T {
    // ...
}
```

Модификатор `inline` влияет и на функцию, и на лямбду, переданную ей: они обе будут встроены в место вызова.

Если же вы хотите, чтобы некоторые лямбды, переданные inline-функции, не были встроены, то отметьте их модификатором `noinline`.

```
inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {
    // ...
}
```

Разница между ними в том, что встраиваемая лямбда может быть вызвана только внутри inline-функции, либо может быть передана в качестве встраиваемого аргумента. В то время как noinline-лямбды можно хранить внутри полей, передавать куда-либо итд.

***

## Return

Иначе работает и оператор `return`. В лямбда-выражении оператор `return` завершает работу всей функции, в которой было вызвано лямбда-выражение. Для выхода только из лямбды используется `label`.

Но если лямбда-выражение передаётся невстраиваемой функции, то использование оператора `return` недопустимо. Если же лямбда-выражение передаётся в inline-функцию, то оператор `return` разрешён и он завершает работу этой функции.

***

## Reified

**Reified** - это ключевое слово, которое может быть использовано только в inline-функциях. Его цель - получение доступа к информации о типе класса.

Допустим у нас есть такая функция:

```
inline fun <T> genericsExample(value: T) {
    println(value)
}
```

Она универсальная и может быть использована для любого типа переменной. Такой эффект достигнут благодаря использованию дженериков (обобщения). Если мы захотим узнать тип класса `T`,

```
inline fun <T> genericsExample(value: T) {
    println(value)
    prinln("Type of T: ${T::class.java}")
}
```

то получим ошибку `Cannot use 'T' as reified type parameter`, так как информация о типе в дженериках отсутствует.

Тут нам на помощь и приходит `reified`. Ключевое слово указывается перед типом, информацию о котором мы хотим получить внутри функции.

```
inline fun <reified T> genericsExample(value: T) {
    println(value)
    println("Type of T: ${T::class.java}")
}
```

За кулисами компилятор заменит тип `T` на фактический, поэтому мы сможем получить о нём информацию и при этом нет необходимости этот тип явно передавать функции.

Также `reified` может быть использован в другом сценарии: для возврата из функции разных типов данных.

```
inline fun<reified T> showMessage(marks: Int): T {
    return when (T::class) {
        Int::class -> marks as T
        String::class -> "Congratulations! you scored more than 90%" as T
        else -> "Please enter valid type" as T
    }
}
```

***

## Полезные ссылки

[Inline Functions](https://kotlinlang.org/docs/reference/inline-functions.html "kotlinlang.org") - официальная документация.  
[Встроенные (inline) функции](https://kotlinlang.ru/docs/reference/inline-functions.html "kotlinlang.ru") - неофициальный перевод на русский язык.
